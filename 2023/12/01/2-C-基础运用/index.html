<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++," />










<meta name="description" content="1.C++关键字C++比C语言多了很多关键字，如下表格：             asm do if return try continue   auto double inline short typedef for   bool dynamic_cast int signed typeid public   break else long sizeof typename throw   cas">
<meta property="og:type" content="article">
<meta property="og:title" content="2.C++基础运用">
<meta property="og:url" content="http://example.com/2023/12/01/2-C-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/index.html">
<meta property="og:site_name" content="limou3434">
<meta property="og:description" content="1.C++关键字C++比C语言多了很多关键字，如下表格：             asm do if return try continue   auto double inline short typedef for   bool dynamic_cast int signed typeid public   break else long sizeof typename throw   cas">
<meta property="og:locale">
<meta property="article:published_time" content="2023-12-01T10:08:22.000Z">
<meta property="article:modified_time" content="2023-12-01T10:09:12.547Z">
<meta property="article:author" content="limou">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2023/12/01/2-C-基础运用/"/>





  <title>2.C++基础运用 | limou3434</title>
  








<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">limou3434</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人学习资料库</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/01/2-C-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="limou3434">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">2.C++基础运用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-01T18:08:22+08:00">
                2023-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-C-关键字"><a href="#1-C-关键字" class="headerlink" title="1.C++关键字"></a>1.C++关键字</h1><p><code>C++</code>比<code>C</code>语言多了很多关键字，如下表格：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>asm</td>
<td>do</td>
<td>if</td>
<td>return</td>
<td>try</td>
<td>continue</td>
</tr>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typedef</td>
<td>for</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typeid</td>
<td>public</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>typename</td>
<td>throw</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>union</td>
<td>wchar_t</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>unsigned</td>
<td>default</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>using</td>
<td>friend</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>virtual</td>
<td>register</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>void</td>
<td>true</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>volatile</td>
<td>while</td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="2-命名空间"><a href="#2-命名空间" class="headerlink" title="2.命名空间"></a>2.命名空间</h1><h2 id="2-1-命名空间概念"><a href="#2-1-命名空间概念" class="headerlink" title="2.1.命名空间概念"></a>2.1.命名空间概念</h2><p>在<code>C++</code>中，变量、函数、类是大量存在的，这些名字都会存储在全局作用域中，因此在使用的时候可能导致很多的冲突。</p>
<p>这种情况在多人协作的情况下尤其突出，多人份提交的代码很容易出现命名冲突的问题。</p>
<p>因此出现了针对命名重复的方案：命名空间。</p>
<ol>
<li><p>使用命名空间可以对标识符的名字进行本地化，避免造成命名冲突或名字污染，<code>namespace</code>就是针对这个问题的的关键字，而<code>C</code>语言没有办法解决这个问题（例如将库函数名字作为新定义的变量，但是这在<code>C++</code>中可以）</p>
</li>
<li><p><code>C++</code>允许同一个工程存在多个同名称的命名空间，编译器最后会合并成同一个命名空间里</p>
</li>
<li><p><code>C++</code>为了防止名字的冲突，便把标准库的东西都放入<code>std</code>这个命名空间。这样就可以使用标准库的名字来命名标准库的变量和函数。因此，要使用标准库的变量和函数也需要写出它的命名空间</p>
</li>
<li><p>由于<code>C++</code>采用命名空间，这个时候就需要注意新的坑了，在包含某些头文件的时候，有可能和自己定义的变量冲突，这个时候就需要使用好<code>namespace</code>关键字</p>
</li>
<li><p>命名空间可以嵌套使用</p>
</li>
</ol>
<h2 id="2-2-创建命名空间"><a href="#2-2-创建命名空间" class="headerlink" title="2.2.创建命名空间"></a>2.2.创建命名空间</h2><p>我们可以使用关键字<code>namespace</code>创建命名空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面是这块命名空间的名字，前者namespace是命名空间的关键字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//在命名空间内定义一个函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Limou</span><span class="comment">//在命名空间内定义一个结构体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">char</span> b;</span><br><span class="line">        <span class="type">float</span> c;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">namespace</span> limou<span class="comment">//在命名空间内嵌套一个命名空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-命名空间合并"><a href="#2-3-命名空间合并" class="headerlink" title="2.3.命名空间合并"></a>2.3.命名空间合并</h2><p>C++对于同名的命名空间不会认为是冲突，而是认为是同一个命名空间，会自动进行合并。</p>
<h2 id="2-4-命名空间授权"><a href="#2-4-命名空间授权" class="headerlink" title="2.4.命名空间授权"></a>2.4.命名空间授权</h2><p>有的人喜欢叫使用命名空间为“展开命名空间”，但是个人认为说成“授权”的方式可能会更好理解，即：命名空间通过<code>using</code>授权给我们使用它的内部成员名字的权限。</p>
<h3 id="2-4-1-小范围使用"><a href="#2-4-1-小范围使用" class="headerlink" title="2.4.1.小范围使用"></a>2.4.1.小范围使用</h3><p>使用作用域限定符<code>::</code>单独引用，这样可以从命名空间中，单独拎出某个名字来使用，虽然可能有些繁琐，但是是最能解决命名冲突的方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命名空间名::名字;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名空间名称::命名空间内的成员名字;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面的&quot;limou3434&quot;是这块命名空间的名字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//在命名空间内定义一个函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> val; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Limou</span><span class="comment">//在命名空间内定义一个结构体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> limou<span class="comment">//在命名空间内嵌套一个命名空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, limou3434::print);</span><br><span class="line">    <span class="comment">//2.使用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, limou3434::<span class="built_in">function</span>(<span class="number">9</span>));</span><br><span class="line">    <span class="comment">//3.使用结构体</span></span><br><span class="line">    limou3434::Limou A;</span><br><span class="line">    A.a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, A.a);</span><br><span class="line">    <span class="comment">//4.使用命名空间内嵌套的命名空间内的变量 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, limou3434::limou::e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-中范围使用"><a href="#2-4-2-中范围使用" class="headerlink" title="2.4.2.中范围使用"></a>2.4.2.中范围使用</h3><p>使用关键字<code>using</code>将命名空间的某个成员引入（项目里经常使用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::名字;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using其实就是英语单词“use”的变形</span></span><br><span class="line"><span class="comment">//using 命名空间名称::命名空间内成员名字;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面是这块命名空间的名字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> limou3434::print;<span class="comment">//单独拎出一个变量，之后可以一直使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, print);</span><br><span class="line">    print += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, val);//这个语句不可以使用，因为没有单独拎出val名字</span></span><br><span class="line">    <span class="keyword">using</span> limou3434::val;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val);<span class="comment">//这里就可以使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-大范围使用"><a href="#2-4-3-大范围使用" class="headerlink" title="2.4.3.大范围使用"></a>2.4.3.大范围使用</h3><p>使用关键字<code>using</code>和<code>namespace</code>将命名空间的整体引入。这样写可能不太好，会把所有标准库的名字全部暴露，有可能和自己写的名字冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面是这块命名空间的名字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> limou3434;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//这里使用了标准命名空间，内部有标准库的各种变量、函数等名字，这里是为了使用cout这个名字，cout的功能是输出，类似printf()，但是比printf()更加智能，可以自动识别变量的类型进行输出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; print;</span><br><span class="line">    cout &lt;&lt; val;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：</p>
<p>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于命名空间中，只有使用<code>using</code>才可以在命名空间外被使用。</p>
</blockquote>
<h1 id="3-C-输入和输出"><a href="#3-C-输入和输出" class="headerlink" title="3.C++输入和输出"></a>3.C++输入和输出</h1><p>在<code>2.4.3.大范围</code>中我们使用了<code>std</code>，接下来让我们来详细了解一下<code>C++</code>特有的输入输出方式。</p>
<h2 id="3-1-输入输出的使用"><a href="#3-1-输入输出的使用" class="headerlink" title="3.1.输入输出的使用"></a>3.1.输入输出的使用</h2><p><code>C++</code>使用了更加灵活方便的<code>cin</code>和<code>cout</code>进行流输入和流输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//必须包含这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//并且释放和cin和cout相关的命名空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//endl是换行的意思，类似&#x27;\n&#x27;，实际上您也可以使用&#x27;\n&#x27;替代endl得到换行的效果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-输入输出的解释"><a href="#3-2-输入输出的解释" class="headerlink" title="3.2.输入输出的解释"></a>3.2.输入输出的解释</h2><ol>
<li><p>使用<code>cout</code>和<code>cin</code>必须包含头文件<code>&lt;iostream&gt;</code>（注意新的<code>C++</code>标准头文件不再使用<code>.h</code>来表示一个头文件。早期标准库将所有功能都在全局域中实现，声明在<code>.h</code>的头文件中，使用的时候<code>include</code>一下就行，后来将这些实现改到<code>std</code>命名空间下。为了和头文件区分并且正确使用命名空间，规定<code>C++</code>头文件不带<code>.h</code>），两者的前缀<code>c</code>就是单词<code>console</code>即“控制台”的缩写。另外，有的老旧编译器还支持<code>#include&lt;isstream.h&gt;</code>的形式，而后续的编译器大部分都不再支持</p>
</li>
<li><p>使用<code>cout</code>和<code>cin</code>必须指出其命名空间<code>std</code>，就是标准命名空间</p>
</li>
<li><p><code>&lt;&lt;</code>是流插入运算符，<code>&gt;&gt;</code>是流提取运算符（也有叫“输入输出符号”的，统称“流运算符”）</p>
</li>
<li><p><code>C++</code>的输入输出可以自动识别变量的类型，无需指定输入输出格式，这里的底层逻辑等您学到“运算符重载”后就可以明白了</p>
</li>
<li><p>虽然是自动控制，但是<code>cout</code>和<code>cin</code>还有其他复杂用法，包括控制输出格式等等，但是这些对比后续学习内容不算重点，就先不在此描述（而且<code>C++</code>也依旧支持<code>C</code>的<code>printf()</code>和<code>scanf()</code>等库函数）</p>
</li>
<li><p><code>std</code>是<code>C++</code>标准库的命名空间，在日常练习中虽然可以直接将整个命名空间全部暴露，但是在大型工程中，一般都会使用作用域限定符，只暴露某一成员</p>
</li>
<li><p><code>endl</code>是“换行”的意思。也是需要包含头文件<code>&lt;iostream&gt;</code>，可以用转义字符<code>\n</code>替代</p>
</li>
</ol>
<blockquote>
<p>补充：</p>
<ol>
<li><p>实际上<code>cin</code>是<code>istream</code>类的对象，而<code>cout</code>是<code>ostream</code>类的对象.</p>
</li>
<li><p>流运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>则是经过运算符重载后的运算符</p>
</li>
</ol>
<p>上面这部分内容等到后面学到“类”的时候再回来看看您就能明白了…</p>
<p>现在对您来说只需要知道这么使用即可！</p>
</blockquote>
<h1 id="4-缺省参数"><a href="#4-缺省参数" class="headerlink" title="4.缺省参数"></a>4.缺省参数</h1><h2 id="4-1-缺省函数的概念"><a href="#4-1-缺省函数的概念" class="headerlink" title="4.1.缺省函数的概念"></a>4.1.缺省函数的概念</h2><p>在<code>C++</code>中声明或定义函数的时候可以为函数指定一个缺省值（默认值，这里是翻译问题，才叫“缺省”）。如果在使用函数的时候没有指定实参，就使用默认值为函数参数，否者使用指定的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span><span class="comment">//这里的a就有一个缺省参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你好！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-全半缺省的使用"><a href="#4-2-全半缺省的使用" class="headerlink" title="4.2.全半缺省的使用"></a>4.2.全半缺省的使用</h2><ol>
<li><p>全缺省：可以只指定一部分参数有默认值，或者全部指定有默认值</p>
</li>
<li><p>半缺省：半缺省函数的参数必须“从右往左”给出，不可间隔给予默认值，因此<code>C++</code>没有允许<code>(,,1)</code>这样的写法</p>
</li>
<li><p>缺省值不能在函数声明和定义里同时出现，要以声明为准（只写在声明中，当然如果函数声明和定义是同一份代码就没有这个问题）</p>
</li>
<li><p>缺省值必须是常量或者全局变量</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="function">voide <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">50</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">//某些具体代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在VS2022中哪怕重定义的缺省的值是一样的也不行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();<span class="comment">//报错无法使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-函数重载"><a href="#5-函数重载" class="headerlink" title="5.函数重载"></a>5.函数重载</h1><h2 id="5-1-重载的概念"><a href="#5-1-重载的概念" class="headerlink" title="5.1.重载的概念"></a>5.1.重载的概念</h2><p>在现实生活中有的词语可以根据上下文语义，从而产生不同的意思，这实际上就是一种重载的体现。</p>
<ol>
<li><p>在<code>C++</code>中允许在同一个“作用域”中声明几个类似功能的同名函数。这些函数的形参列表（形参个数、形参类型、形参顺序）是不同的，常常用来处理实现功能类似、数据不同的问题。而且也根据这个形参的使用来区分不同重载的函数（注意不同命名空间内定义同一个名字的函数虽然可以，但是那个不叫“重载”）</p>
</li>
<li><p>需要注意的是：“返回值的不同、形参名字的不同”都不构成函数重载</p>
</li>
<li><p>实际上<code>cout</code>、<code>cin</code>能够自动识别的本质也是函数重载，在库里面已经帮我们实现好了</p>
</li>
</ol>
<blockquote>
<p>注意：返回值不计入重载</p>
<p>这一点很重要，返回的类型并不能构成重载，理由如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; </span><br></pre></td></tr></table></figure>

<p>如果这里两个<code>add()</code>构成了重载，那么在函数调用的时候（比如：<code>add(1, 2)</code>）就会发生混乱，编译器不知道要调用哪一个函数，是返回<code>int</code>还是<code>double</code>。</p>
</blockquote>
<h2 id="5-2-重载的使用"><a href="#5-2-重载的使用" class="headerlink" title="5.2.重载的使用"></a>5.2.重载的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你好！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">function</span><span class="params">(<span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">function</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-重载的原理"><a href="#5-3-重载的原理" class="headerlink" title="5.3.重载的原理"></a>5.3.重载的原理</h2><p>为什么重载在<code>C</code>语言不支持，而<code>C++</code>语言却支持？（以下现象只有在汇编代码中才能看出来）</p>
<ol>
<li><p>要明白这个过程首先需要重新复习<code>C++</code>代码的编译链接过程：<br> a.预处理：头文件展开、宏替换、条件编译、去掉注释<br> b.编译：语法检查、生成汇编代码<br> c.汇编：将汇编代码转化为二进制机器码，生成目标文件<br> d.链接：将程序合起来，生成可执行程序（这个合起来的意思就是将只给声明的函数地址找到链接起来，如果找不到就是链接错误。而具体的找法就是为每个目标文件做一个符号表，通过符号表来寻找对应的地址）</p>
</li>
<li><p>而在<code>C</code>语言就是在这个链接阶段，查找符号表的时候，有两个同名函数符号且地址不同，这就发生了冲突。即：“<code>C</code>语言直接将函数名作为符号来对应函数地址”</p>
</li>
<li><p>而<code>C++</code>语言在这个链接阶段时，函数符号是根据函数名和参数名来生成的，这样符号名字不一样，地址也不一样，就可以构成函数重载的用法。即：<code>C++</code>语言将函数名和参数类型信息等组合起来构成符号来对应函数地址，这也解释了为什么函数重载需要靠参数类型来标识不同的重载函数</p>
</li>
</ol>
<p>综上所述，<code>C</code>语言不支持函数重载（没有函数修饰规则），<code>C++</code>语言支持函数重载（有函数修饰规则）。</p>
<p>另外，在<code>C++</code>这个符号表里的“函数修饰规则”在不同环境是有可能不一样的，但是一定是依赖函数参数来生成的</p>
<p>这种原理就是“名字修饰”，另外这里有一份<code>VS</code>的“<a target="_blank" rel="noopener" href="https://blog.csdn.net/lioncolumn/article/details/10376891">C&#x2F;C++调用约定博文</a>”</p>
<blockquote>
<p>补充：重载和缺省值的结合</p>
<p>如果给出下面代码会发生什么情况呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;void func(int a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//调用成功</span></span><br><span class="line"> <span class="built_in">func</span>(<span class="number">1</span>);<span class="comment">//调用失败，重载语义模糊，编译器不知道该调用哪一个函数</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h1><h2 id="6-1-引用的概念"><a href="#6-1-引用的概念" class="headerlink" title="6.1.引用的概念"></a>6.1.引用的概念</h2><p>引用不是新定义一个变量，而是为已存变量取个别名，引用变量不会开辟新的内存空间，它和它引用的变量共用同一块内存空间。</p>
<h2 id="6-2-引用的使用"><a href="#6-2-引用的使用" class="headerlink" title="6.2.引用的使用"></a>6.2.引用的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型&amp; 引用变量名(对象名) = 引用实体;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>引用必须在定义的时候就必须进行初始化，<code>C++</code>的引用一旦初始化就不能改变指向，这也是<code>C++</code>不能完全脱离指针的一个体现（<code>Java</code>是可以改变指向的）</p>
</li>
<li><p>一个变量&#x2F;对象可以有多个引用</p>
</li>
<li><p>引用一旦引用一个实体，就再也不能引用其他实体</p>
</li>
<li><p>“引用”是给变量取别名，<code>typedef</code>是给类型取别名，两者有某些相似的地方</p>
</li>
<li><p>还可以给引用后的别名取引用，也就是嵌套引用</p>
</li>
<li><p>引用更多是在函数的参数处使用，尤其是大对象传参的时候会提高效率</p>
</li>
<li><p>引用还可以在函数的返回值处使用，但是注意函数内部定义的变量一旦出函数作用域就会被销毁，此时不能使用引用返回，只能使用传值返回（但是如果这个局部变量被静态关键字<code>static</code>修饰，那就可以直接使用引用返回）</p>
</li>
<li><p>引用的变量类型和引用类型不一样时，会发生权限放大错误，本质是创建了临时变量，而临时变量具有常属性</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用的基本使用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">b = x;<span class="comment">//因此这个语句的意思是“x的值赋给b”，而不是“x成为了b的别名”，这跟指针就有很大的区别</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int&amp; ra = a; //该语句编译时会出错，a为常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ra = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; b = 10; //该语句编译时会出错，b为常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="comment">//int&amp; rd = d; //该语句编译时会出错，由于类型不同所以d会先赋值给一个临时变量，该临时变量的类型是const int，但是使用引用的时候类型不匹配（int和const int不匹配），发生了权限放大</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rd = d;<span class="comment">//此时就可以正常引用了</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-1-多重引用"><a href="#6-2-1-多重引用" class="headerlink" title="6.2.1.多重引用"></a>6.2.1.多重引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用后变量的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//实际变量</span></span><br><span class="line">    <span class="type">int</span>&amp; a1 = a;<span class="comment">//引用1</span></span><br><span class="line">    <span class="type">int</span>&amp; a2 = a;<span class="comment">//引用2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, a1, a2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, &amp;a, &amp;a1, &amp;a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-做函数参数"><a href="#6-2-2-做函数参数" class="headerlink" title="6.2.2.做函数参数"></a>6.2.2.做函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数参数列表的引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="type">int</span> tmp = a;</span><br><span class="line">      a = b;</span><br><span class="line">      b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-做函数返回值"><a href="#6-2-3-做函数返回值" class="headerlink" title="6.2.3.做函数返回值"></a>6.2.3.做函数返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数返回值的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">function</span><span class="params">(<span class="type">int</span>&amp; x)</span><span class="comment">//int&amp; x = i，因此x是i的别名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x++;<span class="comment">//这个x++等价于i++</span></span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//返回x，int&amp; (&quot;function()&quot;) = x，因此函数甚至可以被赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    j = <span class="built_in">function</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">function</span>(i) = <span class="number">10</span>);<span class="comment">//函数也可以赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//但是返回值引用绝对不能返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n <span class="number">0</span>;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> n;<span class="comment">//错误返回，因为n被销毁了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ret = <span class="built_in">Count</span>();</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用引用书写顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">&#125;SL;</span><br><span class="line"><span class="comment">//初始顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushInit</span><span class="params">(SL&amp; s, <span class="type">int</span> capacity = <span class="number">4</span>)</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">//尾插顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushBack</span><span class="params">(SL&amp; S, <span class="type">int</span> x)</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">//修改顺序表</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">SLAt</span><span class="params">(SL&amp; s, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(pos &gt;= <span class="number">0</span> &amp;&amp; pos &lt;=s.size);</span><br><span class="line">    <span class="keyword">return</span> s.a[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SL sl;</span><br><span class="line">    <span class="built_in">SLPushInit</span>(sl);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">1</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">2</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">3</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">4</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sl.size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">SLAt</span>(sl, i) &lt;&lt; endl;<span class="comment">//输出顺序表的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SLAt</span>(sl, <span class="number">0</span>)++;<span class="comment">//拿到s.a[pos]，对其进行++，这是只有C++才有的操作，C语言无法实现</span></span><br><span class="line">    <span class="built_in">SLAt</span>(sl, <span class="number">0</span>) = <span class="number">10</span>;<span class="comment">//拿到s.a[pos]，修改成10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-常引用"><a href="#6-2-4-常引用" class="headerlink" title="6.2.4.常引用"></a>6.2.4.常引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用类型的不匹配情况</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int&amp; a1 = a;//错误引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; a1 = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int&amp; b1 = 10;//错误引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="comment">//int&amp; c1 = c;//错误引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c1 = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用权限的变化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">20</span>;<span class="comment">//c可读不可写</span></span><br><span class="line">    <span class="comment">//int&amp; d = c;//d把c权限放大了（可读可写），这是不被允许的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; d = c;<span class="comment">//这是允许的，属于权限平移</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="number">30</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; f = e;<span class="comment">//但是权限缩小是被允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> h = g;<span class="comment">//这里产生一个临时变量，将存储数据提升后的g，再赋予（拷贝）h（这里g用显式强转也不行，无论是显式还是隐式，都不会改变g本身的类型）</span></span><br><span class="line">    <span class="comment">//double&amp; i = g;//这是不被允许的，因为这里产生一个临时变量，将存储数据提升后的g，而这个临时变量具有常属性，临时变量被h引用的话发生了权限放大</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; i = g;<span class="comment">//这是被允许的，只是发生了权限平移</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; j = <span class="number">3.14</span>;<span class="comment">//这个也是被允许的，因此拥有const修饰的引用允许引用常量。所以如果是在函数形参处使用引用时，如果不需要改变值，就要尽可能使用const修饰</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在C/C++中规定，类型转换（隐式和显式）过程会产生临时变量，如果我们使用const引用这个临时变量，则会让编译器延长这个临时变量的使用时间（生命周期）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：权限放大和缩小只适用在指针和引用上，普通变量之间的赋值是没有作权限要求的，因为这只是做一份临时拷贝。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">(<span class="type">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_3</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">function_1</span>(a);</span><br><span class="line">    <span class="built_in">function_1</span>(b);</span><br><span class="line">    <span class="built_in">function_1</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">function_2</span>(a);</span><br><span class="line">    <span class="comment">//function_2(b);//这是不被允许的</span></span><br><span class="line">    <span class="comment">//function_2(30);//这是不被允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">function_3</span>(a);</span><br><span class="line">    <span class="built_in">function_3</span>(b);</span><br><span class="line">    <span class="built_in">function_3</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; x = <span class="built_in">fun</span>();<span class="comment">//这里返回的a的拷贝，这个拷贝由一个临时变量维护，为了能被引用，被编译器延长了其生命周期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-引用和指针"><a href="#6-3-引用和指针" class="headerlink" title="6.3.引用和指针"></a>6.3.引用和指针</h2><p>指针更强大、更危险、更复杂&#x2F;引用局限一些、更安全、更简单。</p>
<table>
<thead>
<tr>
<th></th>
<th>引用</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td><strong>概念</strong></td>
<td>引用在概念上定义一个变量的别名</td>
<td>指针存储一个变量地址</td>
</tr>
<tr>
<td><strong>空间</strong></td>
<td>引用没有开空间</td>
<td>但是指针开了<code>4</code>个字节或是<code>8</code>个字节的空间（<code>32</code>位或者<code>64</code>位）</td>
</tr>
<tr>
<td><strong>初始</strong></td>
<td>引用在定义时必须初始化</td>
<td>指针被声明后可以不进行初始化</td>
</tr>
<tr>
<td><strong>赋值</strong></td>
<td>引用在初始化时引用一个实体后，就不能再引用其他实体</td>
<td>而指针可以在任何时候指向任何一个同类型实体</td>
</tr>
<tr>
<td><strong>置空</strong></td>
<td>没有<code>NULL</code>引用</td>
<td>但有<code>NULL</code>指针，但是<code>C++</code>改为<code>nullptr</code>指针</td>
</tr>
<tr>
<td><strong>大小</strong></td>
<td>在<code>sizeof</code>中含义不同，引用结果为引用类型的大小</td>
<td>但指针始终是地址空间所占字节个数(<code>32</code>位平台下占<code>4</code>个字节，<code>64</code>位平台下占<code>8</code>个字节）</td>
</tr>
<tr>
<td><strong>运算</strong></td>
<td>引用自加，即引用的实体增加<code>1</code>（加的是类型的<code>1</code>）</td>
<td>指针自加，即指针向后偏移一个类型的大小</td>
</tr>
<tr>
<td><strong>级别</strong></td>
<td>没有多级引用</td>
<td>但是有多级指针</td>
</tr>
<tr>
<td><strong>访问</strong></td>
<td>访问实体方式不同，引用编译器自己处理</td>
<td>指针需要显式解引用</td>
</tr>
<tr>
<td><strong>安全</strong></td>
<td>引用比指针使用起来相对更安全</td>
<td>使用不当时，严重时会使代码奔溃</td>
</tr>
</tbody></table>
<h1 id="7-内联函数"><a href="#7-内联函数" class="headerlink" title="7.内联函数"></a>7.内联函数</h1><h2 id="7-1-内联的概念"><a href="#7-1-内联的概念" class="headerlink" title="7.1.内联的概念"></a>7.1.内联的概念</h2><ol>
<li><p>内联关键字是<code>inline</code>，被其修饰的函数就叫内联函数</p>
</li>
<li><p>编译的时候，只要满足条件，<code>C++</code>编译器会在调用内联函数地方直接展开，没有函数调用建立栈帧的开销，内联函数能提升程序运行的效率，因此这是一种空间换时间的做法</p>
</li>
<li><p>内联关键字的使用很像宏的使用，可以说是宏的优化版本（但是宏：没有类型安全检查、容易出错、不易于调试）</p>
</li>
<li><p>内联可以嵌套内联函数使用</p>
</li>
<li><p>内联函数在<code>VS2022</code>的<code>debug</code>模式下默认是不展开的（<code>rlease</code>），这里打开反汇编就会发现依旧是调用函数，这是为了方便调试设计的，这是可以通过设置规避（“配置属性”-“<code>C/C++</code>”-“常规”-“调试信息格式”-“程序数据库(<code>/Zi</code>)”并且修改“配置属性”-“<code>C/C++</code>”-“优化”-“内联函数拓展”-“只使适用于 <code>__inline(/Obl)</code>”）来查看汇编代码（但是有的编译器不支持）。</p>
</li>
<li><p><code>inline</code>类似<code>C</code>语言里的寄存器变量关键字，只是向编译器发出一个请求，不同编译器关于<code>inline</code>的实现机制可能不一样，也就是说：内联申请不一定会成功！</p>
</li>
<li><p><code>inline</code>本质是一种空间换时间的做法。如果编译器将函数当成内联函数，在编译期间就会将函数体替换函数调用用，对应得优劣势有：<br> a.劣势，有可能使得目标文件变大<br> b.优势，少了调用开销，提高程序的运行效率</p>
</li>
<li><p>一般建议在以下情况来使用<code>inline</code>：将函数规模小、非递归、非频繁调用的函数采用<code>inline</code>修饰，否则编译器有可能会忽略<code>inline</code>的特性（这是因为，函数内部代码指令如果比较长，有可能会让编译的程序暴增，导致编译产生的程序变大。这些更多取决于编译器对<code>inline</code>的实现和理解）</p>
</li>
<li><p>另外被内联关键字修饰的函数，其声明和定义一般不建议分开写，分开有可能导致链接错误（尤其是不在一个翻译单元）。因此最好是把内联函数的声明和定义直接一起写到头文件里，不要去做分离（内联没有必要在符号表生成函数的地址，因此不会生成栈帧操作，链接的时候就会出现错误）！</p>
</li>
</ol>
<blockquote>
<p>补充：可以在同一个项目的不同源文件内定义函数名相同但实现不同的<code>inline</code>函数，因为<code>inline</code>函数会在调用的地方展开，所以符号表中不会有<code>inline</code>函数的符号名，不存在链接冲突这一说法。</p>
</blockquote>
<h2 id="7-2-内联的使用"><a href="#7-2-内联的使用" class="headerlink" title="7.2.内联的使用"></a>7.2.内联的使用</h2><h3 id="7-2-1-正确使用"><a href="#7-2-1-正确使用" class="headerlink" title="7.2.1.正确使用"></a>7.2.1.正确使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//被inline修饰的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; c; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-不在同一个翻译单元"><a href="#7-2-2-不在同一个翻译单元" class="headerlink" title="7.2.2.不在同一个翻译单元"></a>7.2.2.不在同一个翻译单元</h3><p>下面看看一种错误的用法（）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.h内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无法调用内联函数Add</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add_Inline</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; std::endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//对main.cpp来说定义和声明不在一个翻译单元里，无法链接（因为两个源文件属于不同的编译单元，它们会分别进行编译，而不会互相影响，最后链接的时候又不会有地址提供链接。）</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-3-共在同一个翻译单元"><a href="#7-2-3-共在同一个翻译单元" class="headerlink" title="7.2.3.共在同一个翻译单元"></a>7.2.3.共在同一个翻译单元</h3><p>再看看修改后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.h内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_No_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_No_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Add_Inline</span>(x, y);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//成功调用内联函数Add，对inline.cpp来说定义和声明在一个翻译单元里，</span></span><br><span class="line">    <span class="comment">//内联函数是在一个翻译单元内被展开并且在内部被使用的，所以可以使用 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add_No_Inline</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-内联和宏量"><a href="#7-4-内联和宏量" class="headerlink" title="7.4.内联和宏量"></a>7.4.内联和宏量</h2><table>
<thead>
<tr>
<th>宏的优点</th>
<th>宏的缺点</th>
</tr>
</thead>
<tbody><tr>
<td>提高代码的复用性（让你的代码能适应更多种的情况，完成更多种情况的任务，这就是代码的复用性）代码的可维护性变强，修改某些常量值快捷方便</td>
<td>不方便调试带有宏的代码（因为预编译阶段进行了替换，而调试是在编译后的）</td>
</tr>
<tr>
<td>宏函数能提高效率，减少栈帧的建立</td>
<td>导致代码的可读性差、有一点的复杂性，容易误用</td>
</tr>
<tr>
<td></td>
<td>没有类型安全的检查（替换机制），易出现类型错误</td>
</tr>
</tbody></table>
<p>宏的代替方案有如下两点：</p>
<ol>
<li><p>常量定义可以使用<code>C++</code>的<code>const</code>、<code>enum</code>代替宏常量</p>
</li>
<li><p>短小函数定义可以使用<code>C++</code>的内联关键字<code>inline</code>代替宏函数</p>
</li>
</ol>
<h2 id="7-6-内联的约定"><a href="#7-6-内联的约定" class="headerlink" title="7.6.内联的约定"></a>7.6.内联的约定</h2><p>在现代<code>C++</code>中，基本建议尽量使用<code>const</code>、<code>enum</code>、<code>inline</code>，而不使用宏。</p>
<blockquote>
<p>补充：</p>
<ol>
<li><p><code>const</code>定义的常量只有一次拷贝（就是只有一个值）</p>
</li>
<li><p>而<code>define</code>定义的变量在内存中并没有拷贝，因为所有的预处理指令都在预处理时进行了替换</p>
</li>
</ol>
</blockquote>
<h1 id="8-typedef和auto"><a href="#8-typedef和auto" class="headerlink" title="8.typedef和auto"></a>8.typedef和auto</h1><h2 id="8-1-typedef关键字"><a href="#8-1-typedef关键字" class="headerlink" title="8.1.typedef关键字"></a>8.1.typedef关键字</h2><p>随着一个工程的扩大，程序中用到的类型也越来越复杂，经常体现在：</p>
<ol>
<li><p>类型难以拼写，容易拼错</p>
</li>
<li><p>含义不明确，导致用错</p>
</li>
</ol>
<p>在编程时，常常需要把表达式的值赋值给变量，这就要求在声明变量的时候就要清楚知道表达式的类型。要做到这点并非那么容易，而<code>typedef</code>也还不够智能，而且因此<code>C++11</code>给<code>auto</code>一个新的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*没有使用tepedef重命名*/</span></span><br><span class="line"><span class="comment">//这段代码现在看不懂没关系，您只需要知道类型的名字确实很长就对了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;std::string, std::string&gt;m&#123; &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;苹果&quot;</span> &#125;, &#123; <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;橙子&quot;</span> &#125;, &#123;<span class="string">&quot;pear&quot;</span>, <span class="string">&quot;梨&quot;</span>&#125; &#125;;</span><br><span class="line">    std::map&lt;std::string, std::string&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//其中std::map&lt;std::string,std::string&gt;::iterator是一个类型，但是类型的名字太长了，容易写错，可以尝试使用typedef给这个类型取个别名</span></span><br><span class="line">    <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//....    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-auto关键字"><a href="#8-2-auto关键字" class="headerlink" title="8.2.auto关键字"></a>8.2.auto关键字</h2><ol>
<li><p>在<code>C++11</code>的标准中，<code>auto</code>不再是存储类型说明符，而是一个新的类型指示符，来指示编译器</p>
</li>
<li><p><code>auto</code>声明的变量必须由编译器在编译时期推导而得 </p>
</li>
<li><p>使用<code>auto</code>定义变量时必须对其进行初始化，在编译阶段编译器会根据初始化表达式来推导<code>auto</code>的实际类型。因此<code>auto</code>并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。</p>
</li>
</ol>
<p>如果结合指针和引用来使用（这实际上也是指针和引用的区别之一）：</p>
<ol>
<li><p>结合指针的话，<code>auto</code>和<code>auto*</code>是没有区别的</p>
</li>
<li><p>结合引用的话，<code>auto</code>和<code>auto&amp;</code>是有区别的，必须要加<code>&amp;</code></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一个变量</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.结合指针</span></span><br><span class="line">    <span class="keyword">auto</span> a = &amp;x;</span><br><span class="line">    <span class="keyword">auto</span>* b = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.结合引用</span></span><br><span class="line">    <span class="keyword">auto</span> c = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp; d = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试类型和输出，typeid可以打印类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改变量</span></span><br><span class="line">    *a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    *b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; x&lt;&lt; endl;</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    d = <span class="number">40</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在同一行使用<code>auto</code>来声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//正确使用  </span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//错误使用 </span></span><br><span class="line">    <span class="comment">//auto c = 3, d = 4.0;//该行代码会编译失败，因为c和d的初始化表达式类型不同    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>auto</code>不能推导的场景有：</p>
<ol>
<li><p><code>auto</code>不能作为函数的形参，因为函数编译是要建立栈帧的，这个时候都不知道形参的大小，怎么知道从哪里开始创建栈帧呢？ </p>
</li>
<li><p><code>auto</code>不能用来声明数组</p>
</li>
</ol>
<p>另外，为了避免和<code>C++98</code>的<code>auto</code>发生混淆，<code>C++11</code>只保留了<code>auto</code>作为类型指示符的用法。</p>
<p><code>auto</code>的最大的优势其实在于<code>C++11</code>提供的新式<code>for</code>循环以及<code>lambda</code>表达式，<code>lambda</code>表达式我们先不提，但是下面我们来了解一下范围<code>for</code>。</p>
<h1 id="9-基于范围的for循环"><a href="#9-基于范围的for循环" class="headerlink" title="9.基于范围的for循环"></a>9.基于范围的for循环</h1><p>这不是<code>C++</code>的首创，而是借鉴其他语言引入进来的。</p>
<h2 id="9-1-范围for的使用"><a href="#9-1-范围for的使用" class="headerlink" title="9.1.范围for的使用"></a>9.1.范围for的使用</h2><ol>
<li>在<code>C++</code>98之前，遍历一个数组可以按照以下的方式使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使用C++98遍历方式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>* p = array; p &lt; array + <span class="built_in">sizeof</span>(array)/ <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>C++11</code>中可以使用基于范围的<code>for</code>循环。<code>for</code>后面的括号由冒号<code>:</code>分为两部分，第一部分是范围内用于迭代的变量，第二部分表示被迭代的范围</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使用C++11遍历方式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : array)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : array)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-范围for的条件"><a href="#9-2-范围for的条件" class="headerlink" title="9.2.范围for的条件"></a>9.2.范围for的条件</h2><p>由于<code>C++</code>不支持直接传数组（这样消耗大，浪费）所以在函数传数组的时候必须提供<code>begin</code>和<code>end</code>方法，<code>begin</code>和<code>end</code>就是<code>for</code>循环迭代的范围（有关<code>begin</code>和<code>end</code>的具体使用后面在使用<code>string</code>类再说）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> arr[])</span><span class="comment">//这个函数是不正确的，因为arr不是数组名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : arr)<span class="comment">//无法使用范围for</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-指针空值nullptr"><a href="#10-指针空值nullptr" class="headerlink" title="10.指针空值nullptr"></a>10.指针空值nullptr</h1><h2 id="10-1-NULL的概念"><a href="#10-1-NULL的概念" class="headerlink" title="10.1.NULL的概念"></a>10.1.NULL的概念</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0<span class="comment">//在C++语言中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)<span class="comment">//在C语言中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//在C++98中，字面量0既可以是一个整型数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看作整型常量，如果这么使用NULL时，就会具有一定的麻烦，这是C++设计的一个失误，都是C++不敢去掉这个定义，为了保证兼容性就新定义了nullptr。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span><span class="comment">//函数重载</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f(int*)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//误用第一个函数，因为处理NULL的时候，NULL是被定义为0的</span></span><br><span class="line">    <span class="built_in">f</span>((<span class="type">int</span>*)<span class="literal">NULL</span>);<span class="comment">//需要使用强制类型转换才可以使用第二个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2-nullptr的概念"><a href="#10-2-nullptr的概念" class="headerlink" title="10.2.nullptr的概念"></a>10.2.nullptr的概念</h2><ol>
<li><p>而在使用<code>nullptr</code>表示指针空值时，不需要包含头文件，因为<code>nullptr</code>是<code>C++11</code>作为新关键字引入的6</p>
</li>
<li><p>在<code>C++11</code>中，<code>sizeof(nullptr)</code>与<code>sizeof((void*)0)</code>所占的字节数相同</p>
</li>
<li><p>为了提高代码的健壮性，在后续表示指针空值时建议最好使用<code>nullptr</code></p>
</li>
</ol>
<h1 id="11-decltype"><a href="#11-decltype" class="headerlink" title="11.decltype"></a>11.decltype</h1><p><code>decltype</code> 可以根据表达式的类型来创建变量，某些时候可以使用 <code>auto</code> 替代，但有些情况不可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">2.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decltype 可以根据表达式的类型来创建变量</span></span><br><span class="line">    <span class="keyword">decltype</span>(x * y) ret;<span class="comment">//ret的类型变成了 double</span></span><br><span class="line">    <span class="keyword">decltype</span>(&amp;x) p;<span class="comment">//p的类型变成了 const int*</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(ret).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2023/12/01/1-C-%E5%AF%BC%E8%AE%BA/" rel="next" title="1.C++导论">
                <i class="fa fa-chevron-left"></i> 1.C++导论
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2023/12/01/3-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="prev" title="3.C++类的基本概述（上）">
                3.C++类的基本概述（上） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-C-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.</span> <span class="nav-text">1.C++关键字</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">2.</span> <span class="nav-text">2.命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1.命名空间概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">2.2.</span> <span class="nav-text">2.2.创建命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="nav-number">2.3.</span> <span class="nav-text">2.3.命名空间合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%8E%88%E6%9D%83"><span class="nav-number">2.4.</span> <span class="nav-text">2.4.命名空间授权</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-1-%E5%B0%8F%E8%8C%83%E5%9B%B4%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1.小范围使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-%E4%B8%AD%E8%8C%83%E5%9B%B4%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2.中范围使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-3-%E5%A4%A7%E8%8C%83%E5%9B%B4%E4%BD%BF%E7%94%A8"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3.大范围使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-C-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">3.</span> <span class="nav-text">3.C++输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">3.1.输入输出的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="nav-number">3.2.</span> <span class="nav-text">3.2.输入输出的解释</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">4.缺省参数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E7%BC%BA%E7%9C%81%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">4.1.缺省函数的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%85%A8%E5%8D%8A%E7%BC%BA%E7%9C%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">4.2.全半缺省的使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">5.</span> <span class="nav-text">5.函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">5.1.重载的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E9%87%8D%E8%BD%BD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">5.2.重载的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">5.3.</span> <span class="nav-text">5.3.重载的原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%BC%95%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">6.引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">6.1.引用的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">6.2.引用的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E5%A4%9A%E9%87%8D%E5%BC%95%E7%94%A8"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1.多重引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2.做函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-%E5%81%9A%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3.做函数返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="nav-number">6.2.4.</span> <span class="nav-text">6.2.4.常引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88"><span class="nav-number">6.3.</span> <span class="nav-text">6.3.引用和指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">7.内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%86%85%E8%81%94%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.</span> <span class="nav-text">7.1.内联的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E5%86%85%E8%81%94%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">7.2.内联的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1.正确使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BF%BB%E8%AF%91%E5%8D%95%E5%85%83"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2.不在同一个翻译单元</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%85%B1%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BF%BB%E8%AF%91%E5%8D%95%E5%85%83"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.2.3.共在同一个翻译单元</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E5%86%85%E8%81%94%E5%92%8C%E5%AE%8F%E9%87%8F"><span class="nav-number">7.3.</span> <span class="nav-text">7.4.内联和宏量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-%E5%86%85%E8%81%94%E7%9A%84%E7%BA%A6%E5%AE%9A"><span class="nav-number">7.4.</span> <span class="nav-text">7.6.内联的约定</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-typedef%E5%92%8Cauto"><span class="nav-number">8.</span> <span class="nav-text">8.typedef和auto</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-typedef%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">8.1.</span> <span class="nav-text">8.1.typedef关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-auto%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">8.2.</span> <span class="nav-text">8.2.auto关键字</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="nav-number">9.</span> <span class="nav-text">9.基于范围的for循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-%E8%8C%83%E5%9B%B4for%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">9.1.</span> <span class="nav-text">9.1.范围for的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-%E8%8C%83%E5%9B%B4for%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">9.2.</span> <span class="nav-text">9.2.范围for的条件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-%E6%8C%87%E9%92%88%E7%A9%BA%E5%80%BCnullptr"><span class="nav-number">10.</span> <span class="nav-text">10.指针空值nullptr</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-NULL%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">10.1.</span> <span class="nav-text">10.1.NULL的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-nullptr%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">10.2.</span> <span class="nav-text">10.2.nullptr的概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-decltype"><span class="nav-number">11.</span> <span class="nav-text">11.decltype</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">limou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
