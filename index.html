<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本资料库主要存储limou的个人学习知识文章">
<meta property="og:type" content="website">
<meta property="og:title" content="limou3434">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="limou3434">
<meta property="og:description" content="本资料库主要存储limou的个人学习知识文章">
<meta property="og:locale">
<meta property="article:author" content="limou">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>limou3434</title>
  








<meta name="generator" content="Hexo 7.0.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">limou3434</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">个人学习资料库</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/%20" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/01/5-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="limou3434">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/01/5-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8B%EF%BC%89/" itemprop="url">5.C++类的基本概述（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-01T18:10:03+08:00">
                2023-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前我们学习的模板能达到泛型的原因是：使用了“泛型的类型”，但是如果经过后面的“造轮子”（后面会尝试实现一下<code>STL</code>的一些类模板），就会很明显发现泛型不仅仅是类型的问题，例如：“适配器”的使用（在后面双端队列里有体现），实际上就是一种泛型，对于泛型的理解我们不能仅限于类型。</p>
<h1 id="1-非类型模板"><a href="#1-非类型模板" class="headerlink" title="1.非类型模板"></a>1.非类型模板</h1><p>模板除了类型模板，还有非类型模板。</p>
<ol>
<li><p>类型模板：出现在模板的参数列表中，跟在<code>class</code>或者<code>typname</code>后的参数类型名称</p>
</li>
<li><p>非类型模板：使用一个常量作为类的一个非类型模板参数，在模板类&#x2F;模板函数中可以将该参数作为常量来使用，且不能修改。并且，这里非类型模板参数也可以使用缺省值</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有非类型模板参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _arr[NUM];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data&lt;<span class="type">int</span>&gt; a1;</span><br><span class="line">    <span class="comment">//无法修改初始化大小（注意是初始化的时候修改大小）</span></span><br><span class="line">    <span class="comment">//只能手动调整#define的值</span></span><br><span class="line">    <span class="comment">//和之前的typedef的问题类似</span></span><br><span class="line">    Data&lt;<span class="type">double</span>&gt; a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候就可以使用非类型模板参数，这个参数是一个常量，更加准确来说是不可被修改的整形常量（包括布尔类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有非类型模板参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//#define NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N = <span class="number">50</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Data</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _arr[N];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data&lt;<span class="type">int</span>&gt; a1;<span class="comment">//默认初始化申请50个空间</span></span><br><span class="line">    Data&lt;<span class="type">double</span>, <span class="number">20</span>&gt; a2;<span class="comment">//初始化时申请20个空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可能会疑惑：为什么不可以初始化先使用<code>new</code>开辟固定的空间，等到后续操作进行扩容操作呢？注意这里只是利用这个例子来简述语法特性，并不是实际的用途（在后续“位图”等知识中有很大的价值）。</p>
<blockquote>
<p>  补充：除了使用这个常量，还可以将这个常量作为一个类的标识数字来使用。</p>
</blockquote>
<p>函数模板也可以使用这一特性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">size_t</span> N = <span class="number">50</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Data</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T _arr[N];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">long</span> NUM = <span class="number">50</span>&gt;<span class="comment">//演示了其他整形</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">function</span>(T&amp; i)</span><br><span class="line">&#123;</span><br><span class="line">    i = NUM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data&lt;<span class="type">int</span>, <span class="number">10</span>&gt; a1;</span><br><span class="line">    Data&lt;<span class="type">int</span>, <span class="number">100</span>&gt; a2;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">function</span>&lt;<span class="type">int</span>, <span class="number">200</span>&gt;(i);<span class="comment">//演示了函数修改非类型模板参数</span></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>C++ 11</code>搞的新容器：静态数组<code>array</code>，其类模板就是使用了这个非类型模板参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 10&gt;arr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可惜静态数组不会进行初始化（吐槽：<code>std::array</code>当参数传递仍然要把数组的长度传过去，挺好玩的…），也支持范围<code>for</code>，并且越界检查比较严格（传统数组是抽查，但是静态数组是读写越界全面检查，避免代码崩溃）。</p>
<p>嘛…感觉优势不算很大（大不了使用<code>vector</code>，这也可以查找越界，还可以使用列表初始化）所以推广并不高。这个容器有点为了强迫症而统一<code>STL</code>风格的感觉。</p>
<p>类似<code>deque</code>在<code>list</code>和<code>vector</code>的感觉（后面会讲），静态数组就是传统数组和<code>vector</code>之间的方案。</p>
<h1 id="2-模板特化"><a href="#2-模板特化" class="headerlink" title="2.模板特化"></a>2.模板特化</h1><p>通常模板可以实现和类型无关的代码，但是有一些特殊的类型可能会得到一些错误的、不符合预期的结果，因此需要进行特殊处理，这就有了“模板特化”这个概念。</p>
<h2 id="2-1-类模板特化"><a href="#2-1-类模板特化" class="headerlink" title="2.1.类模板特化"></a>2.1.类模板特化</h2><h3 id="2-1-1-全特化"><a href="#2-1-1-全特化" class="headerlink" title="2.1.1.全特化"></a>2.1.1.全特化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 _d1;</span><br><span class="line">    T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="comment">//全特化，必须要写这句</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;<span class="comment">//这里指定了特定的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data&lt;int, char&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _d1;</span><br><span class="line">    <span class="type">char</span> _d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data&lt;<span class="type">int</span>, <span class="type">int</span>&gt; d1;</span><br><span class="line">    Data&lt;<span class="type">int</span>, <span class="type">char</span>&gt; d2;<span class="comment">//这样就会直接调用全特化的模板，不会再去类模板构造</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">TestVector</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-偏特化"><a href="#2-1-2-偏特化" class="headerlink" title="2.1.2.偏特化"></a>2.1.2.偏特化</h3><p>除了全特化，还可以进行偏特化。在下述代码中，我们可以看到偏特化不仅只是做了一些类型的指定，也可以对类型做进一步限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> T1&amp; d1, <span class="type">const</span> T2&amp; d2) : _d1(d1), _d2(d2)</span><br><span class="line">    &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 _d1;</span><br><span class="line">    T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.部分类模板参数特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span>&lt;T1, <span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> T1&amp; d1, <span class="type">const</span> <span class="type">int</span>&amp; d2) : _d1(d1), _d2(d2)</span><br><span class="line">    &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1, int&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 _d1;</span><br><span class="line">    <span class="type">int</span> _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1.对两个参数进行进一步限制，偏特化为指针类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="comment">//这里也是必须写，和全特化有些不同</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1*, T2*&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> T1&amp; d1, <span class="type">const</span> T2&amp; d2) : _d1(d1), _d2(d2)</span><br><span class="line">    &#123; cout &lt;&lt; <span class="string">&quot;Data&lt;T1*, T2*&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 _d1;<span class="comment">//注意其成员不是指针，仍然是原类型</span></span><br><span class="line">    T2 _d2;<span class="comment">//注意其成员不是指针，仍然是原类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2.对两个参数进行进一步限制，偏特化为引用类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;<span class="comment">//这里也是必须写，和全特化有些不同</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &lt;T1&amp;, T2&amp;&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> T1&amp; d1, <span class="type">const</span> T2&amp; d2) : _d1(d1), _d2(d2)</span><br><span class="line">    &#123;cout &lt;&lt; <span class="string">&quot;Data&lt;T1&amp;, T2&amp;&gt;&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 _d1;</span><br><span class="line">    T2 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title">d1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;<span class="comment">//调用基础的类模板</span></span><br><span class="line">    <span class="function">Data&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(<span class="number">30</span>, <span class="number">40</span>)</span></span>;<span class="comment">//调用偏特化的类模板</span></span><br><span class="line">    <span class="function">Data&lt;<span class="type">int</span>*, <span class="type">int</span>*&gt; <span class="title">d3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">//调用偏特化的指针版本</span></span><br><span class="line">    <span class="function">Data&lt;<span class="type">int</span>&amp;, <span class="type">int</span>&amp;&gt; <span class="title">d4</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;<span class="comment">//调用偏特化的引用版本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  补充：偏特化会使得特化更加强大，某些程度上来说比全特化更加常用。</p>
</blockquote>
<p>因此可以总结类模板的特化语法就是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.原类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="comment">/*...*/</span>, <span class="keyword">class</span> <span class="title class_">Tn</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.特化类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;/*填入仍旧继续使用的泛型（如果都使用可以省略这里）*/&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span>&lt;/*指定特定的类型，并且写入仍旧使用的泛型，注意顺序*/&gt;</span><br><span class="line">&#123;<span class="comment">/*...*/</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-函数模板特化"><a href="#2-2-函数模板特化" class="headerlink" title="2.2.函数模板特化"></a>2.2.函数模板特化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> d) : _d(d) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Data&amp; x)</span><br><span class="line">    &#123; <span class="keyword">return</span> _d &lt; x._d; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Less</span><span class="params">(T left, T right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left &lt; right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特化函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">bool</span> <span class="built_in">Less</span>&lt;Data*&gt;(Data* left, Data* right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (*left) &lt; (*right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;&gt;</span></span><br><span class="line"><span class="comment">bool Less&lt;Data*&gt;(const Data* &amp; left, const Data* &amp; right)//这种写法很特殊，是没有办法通过的，原本是为了使用const修饰引用变量，避免引用变量被修改，但是由于指针和const修饰的特殊性，导致const修饰了*，因此只能改成：(Data* const&amp; left, Data* const&amp; right)这种写法虽然奇怪，但是却是正确的。</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return (*left) &lt; (*right);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//调用了普通的函数模板</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Data <span class="title">d1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Data <span class="title">d2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(d1, d2) &lt;&lt; endl;<span class="comment">//调用了普通的函数模板</span></span><br><span class="line"></span><br><span class="line">    Data* p1 = &amp;d1;</span><br><span class="line">    Data* p2 = &amp;d2;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Less</span>(p1, p2) &lt;&lt; endl;<span class="comment">//调用特化后的函数模板，虽然这种调用看起来很奇怪</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>1</code>：区分好“匹配”和“特化”和“实例化”。</p>
<ol>
<li><strong>匹配</strong>：是有相匹配的类型，可以使用对应的模板</li>
<li><strong>实例化</strong>：是编译器自己做的，将匹配对应的模板进行实例化</li>
<li><strong>特化</strong>：特化不是全新的模板，必须依赖模板，不可以单独存在</li>
</ol>
<p>注意<code>2</code>：实际上特化更加适合类模板一些，实际上函数重载（重载）对比函数模板特化（匹配）更加简单。</p>
</blockquote>
<h1 id="3-函数模板声明定义分离"><a href="#3-函数模板声明定义分离" class="headerlink" title="3.函数模板声明定义分离"></a>3.函数模板声明定义分离</h1><p>这一点凸显在函数的声明定义的分离上，假设有下面三个文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function.h内声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NoTemplateAdd</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; left, <span class="type">const</span> <span class="type">int</span>&amp; right)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function.cpp内定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">Add</span><span class="params">(<span class="type">const</span> T&amp; left, <span class="type">const</span> T&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NoTemplateAdd</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; left, <span class="type">const</span> <span class="type">int</span>&amp; right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp内包含头文件并且调用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//链接错误</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add</span>(<span class="number">1.0</span>, <span class="number">2.0</span>);<span class="comment">//链接错误</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">NoTemplateAdd</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//成功调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现函数模板没有办法声明和定义分离在两个文件中，会显示链接错误（但是普通的函数可以）。</p>
<p>让我们来分析一下这里面的原因：</p>
<ol>
<li><code>C/C++</code>要运行程序，就需要经历“预处理-编译-汇编-链接”</li>
<li>在编译阶段，会对多份源文件做各自的编译（进行词法、语法、语义分析、错误检查等）并且生成多份的汇编代码（注意头文件是不会参与编译的）这个时候在<code>function.obj</code>或者说<code>function.o</code>中，由于编译器没有看到函数的实例化，因此没有生成具体的加法函数。</li>
<li>而在<code>main.obj</code>或者<code>main.o</code>中，编译器看到有加法函数的调用，但是暂时不知道具体的实现，因此就暂时放进了符号表里等待后续链接</li>
<li>在链接阶段由于没有实例化，因此<code>function.obj</code>或者说<code>function.o</code>中没有加法函数的定义，根本就无法提供加法函数的地址在符号表里供<code>main.obj</code>或者<code>main.o</code>链接</li>
</ol>
<p>因此后续链接的时候就会报错，即“链接错误”。</p>
<p>如果一定要分离，有两种方法：</p>
<ol>
<li><p>进行显示实例化（有缺陷）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">(T value)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//function.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunction</span><span class="params">(T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显式实例化int类型的函数模板</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">MyFunction</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> value);</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用int版本的函数模板</span></span><br><span class="line">    <span class="built_in">MyFunction</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在一个翻译单元里分离，即：干脆直接将定义和声明都写在一个<code>.hpp</code>内（这样直接就有函数地址出来，不需要等待链接），这样做是更加推荐的。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/01/4-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%AD%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="limou3434">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/01/4-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%AD%EF%BC%89/" itemprop="url">4.C++类的基本概述（中）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-01T18:09:57+08:00">
                2023-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-初始化列表"><a href="#1-初始化列表" class="headerlink" title="1.初始化列表"></a>1.初始化列表</h1><h2 id="1-1-函数体赋值初始值"><a href="#1-1-函数体赋值初始值" class="headerlink" title="1.1.函数体赋值初始值"></a>1.1.函数体赋值初始值</h2><p>在创建对象的时候，编译器通过调用构造函数，给每一个对象一个初始值，注意！只是给定初始值，而不是进行初始化。因为初始化只有一次，而类似构造函数在函数体内赋值初始值可以多次赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注意这里没有提供默认构造函数，</span></span><br><span class="line"><span class="comment">        注意默认构造函数有三种：</span></span><br><span class="line"><span class="comment">        无参的、全缺省的、编译器默认生成的，</span></span><br><span class="line"><span class="comment">        这里需要传输参数，所以不是默认构造函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data2</span>(<span class="type">int</span> a2, <span class="type">int</span> b2, <span class="type">int</span> c2, <span class="type">int</span> d2)</span><br><span class="line">    &#123;</span><br><span class="line">        _a2 = a2;</span><br><span class="line">        _b2 = b2;</span><br><span class="line">        _c2 = c2;</span><br><span class="line">        _d2 = d2;<span class="comment">//对于此时的b对象来说，_d2会调用Data1的默认构造函数先进行构造，结果发现没有默认构造函数，因此调用失败，连把d2赋值的能力都没有</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a2;</span><br><span class="line">    <span class="type">int</span> _b2;</span><br><span class="line">    <span class="type">int</span> _c2;</span><br><span class="line">    Data1 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//成功调用了Data1的带参构造函数</span></span><br><span class="line">    <span class="function">Data2 <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span></span>;<span class="comment">//调用失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们先构造好一个<code>Data1</code>，再通过默认拷贝构造赋值给<code>_d2</code>呢？依旧是不行的，原因依旧是<code>_d2</code>在定义的时候会自动调用默认构造函数，无法调用，在这一步出现问题，后续怎么折腾都没有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注意这里没有提供默认构造函数，</span></span><br><span class="line"><span class="comment">        注意默认构造函数有三种：</span></span><br><span class="line"><span class="comment">        无参的、全缺省的、编译器默认生成的，</span></span><br><span class="line"><span class="comment">        这里需要传输参数，所以不是默认构造函数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data2</span>(<span class="type">int</span> a2, <span class="type">int</span> b2, <span class="type">int</span> c2, <span class="type">int</span> d2)</span><br><span class="line">    &#123;</span><br><span class="line">        _a2 = a2;</span><br><span class="line">        _b2 = b2;</span><br><span class="line">        _c2 = c2;</span><br><span class="line">        <span class="function">Data1 <span class="title">cache</span><span class="params">(d2)</span></span>;<span class="comment">//cache创建成功了</span></span><br><span class="line">        _d2 = cache;<span class="comment">//但是对于此时的b对象来说，b内部的_d2依旧会先调用Data1的默认构造函数，结果发现没有默认构造函数，因此调用失败，连定义_d2都没有办法，更别说赋值给_d2了</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a2;</span><br><span class="line">    <span class="type">int</span> _b2;</span><br><span class="line">    <span class="type">int</span> _c2;</span><br><span class="line">    Data1 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;<span class="comment">//成功调用了Data1的带参构造函数</span></span><br><span class="line">    <span class="function">Data2 <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span></span>;<span class="comment">//调用失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要成功运行的话只能写一个默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1 = <span class="number">0</span>)<span class="comment">//提供了默认构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data2</span>(<span class="type">int</span> a2, <span class="type">int</span> b2, <span class="type">int</span> c2, <span class="type">int</span> d2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//函数体内初始化</span></span><br><span class="line">        _a2 = a2;</span><br><span class="line">        _b2 = b2;</span><br><span class="line">        _c2 = c2;</span><br><span class="line">        _d2 = d2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a2;</span><br><span class="line">    <span class="type">int</span> _b2;</span><br><span class="line">    <span class="type">int</span> _c2;</span><br><span class="line">    Data1 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Data2 <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然成功进行了初始化，但是这种初始化未免太过麻烦，因此<code>C++</code>又设计了“初始化列表”这种用法，使得构造函数能够对变量直接进行初始化，而不是赋值初始值。</p>
<h2 id="1-2-初始化列表初始化"><a href="#1-2-初始化列表初始化" class="headerlink" title="1.2.初始化列表初始化"></a>1.2.初始化列表初始化</h2><p>结合了初始化列表，构造函数才是真正的构造函数（集合了定义初始化和赋值初始值）。</p>
<p>初始化列表的格式：以一个冒号<code>:</code>开头，接着以一个逗号分割的数据成员列表，每一个成员变量后面跟着一个放在括号中的初始值或表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1)<span class="comment">//提供了构造函数，但不是默认构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data2</span>(<span class="type">int</span> a2, <span class="type">int</span> b2, <span class="type">int</span> c2, <span class="type">int</span> d2)</span><br><span class="line">    <span class="comment">//函数体外初始化</span></span><br><span class="line">        : _a2(a2)</span><br><span class="line">        , _b2(b2)</span><br><span class="line">        , _c2(c2)</span><br><span class="line">        , _d2(d2)<span class="comment">//相当于显示调用上面的构造函数来定义_d2</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a2;</span><br><span class="line">    <span class="type">int</span> _b2;</span><br><span class="line">    <span class="type">int</span> _c2;</span><br><span class="line">    Data1 _d2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(i)</span></span>;</span><br><span class="line">    <span class="function">Data2 <span class="title">b</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在一般情况下，使用“函数体内赋值初始值”和“函数体外初始化（使用初始化列表初始化）”没有太大区别，但是有一些情况就必须使用初始化列表。</p>
<ol>
<li><p>引用成员变量</p>
</li>
<li><p><code>const</code>成员变量</p>
</li>
<li><p>自定义类型成员（且该自定义类型没有默认构造函数时）</p>
</li>
</ol>
<blockquote>
<p>注意：初始化列表可以认为是成员变量定义的地方。</p>
</blockquote>
<p>最上面的问题实际上就是上面的情况<code>3</code>，下面介绍其他的情况。</p>
<h3 id="1-2-1-情况1：引用成员变量"><a href="#1-2-1-情况1：引用成员变量" class="headerlink" title="1.2.1.情况1：引用成员变量"></a>1.2.1.情况1：引用成员变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1, <span class="type">int</span> b1, <span class="type">int</span> c1, <span class="type">int</span> d1)</span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">        _b1 = b1;</span><br><span class="line">        _c1 = c1;</span><br><span class="line">        _d1 = d1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">    <span class="type">int</span> _b1;</span><br><span class="line">    <span class="type">int</span> _c1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> _d1;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里虽然可以定义_d1，</span></span><br><span class="line"><span class="comment">    但是却不允许后续赋值了，</span></span><br><span class="line"><span class="comment">    因为已经提前定义了const变量，</span></span><br><span class="line"><span class="comment">    没有办法赋值了（赋值相当于是一种修改）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>const</code>必须在定义的地方初始化，因此对于<code>const</code>成员变量，就只能改成初始化列表了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1, <span class="type">int</span> b1, <span class="type">int</span> c1, <span class="type">int</span> d1)</span><br><span class="line">        :_d1(d1)</span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">        _b1 = b1;</span><br><span class="line">        _c1 = c1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">    <span class="type">int</span> _b1;</span><br><span class="line">    <span class="type">int</span> _c1;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> _d1;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里虽然可以定义_d1，</span></span><br><span class="line"><span class="comment">    但是却不允许后续赋值了，</span></span><br><span class="line"><span class="comment">    因为已经提前定义了const变量，</span></span><br><span class="line"><span class="comment">    没有办法赋值了（赋值相当于是一种修改）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-情况2：const成员变量"><a href="#1-2-2-情况2：const成员变量" class="headerlink" title="1.2.2.情况2：const成员变量"></a>1.2.2.情况2：const成员变量</h3><p>对于引用成员变量也是需要使用初始化列表的，这是因为引用也必须在定义的时候指定初始化，不可以通过赋值的方式，给一个变量起别名（<code>int&amp; a; a = b;</code>这种写法是不被允许的，<code>a</code>并不会是<code>b</code>的别名，必须写成<code>int&amp; a = b</code>）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1, <span class="type">int</span> b1, <span class="type">int</span> c1, <span class="type">int</span>&amp; d1)</span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">        _b1 = b1;</span><br><span class="line">        _c1 = c1;</span><br><span class="line">        _d1 = d1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">    <span class="type">int</span> _b1;</span><br><span class="line">    <span class="type">int</span> _c1;</span><br><span class="line">    <span class="type">int</span>&amp; _d1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, i)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> a1, <span class="type">int</span> b1, <span class="type">int</span> c1, <span class="type">int</span>&amp; d1)</span><br><span class="line">        : _d1(d1)</span><br><span class="line">    &#123;</span><br><span class="line">        _a1 = a1;</span><br><span class="line">        _b1 = b1;</span><br><span class="line">        _c1 = c1;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">    <span class="type">int</span> _b1;</span><br><span class="line">    <span class="type">int</span> _c1;</span><br><span class="line">    <span class="type">int</span>&amp; _d1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Data1 <span class="title">a</span><span class="params">(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, i)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-情况3：自定义类型成员"><a href="#1-2-3-情况3：自定义类型成员" class="headerlink" title="1.2.3.情况3：自定义类型成员"></a>1.2.3.情况3：自定义类型成员</h3><p>情况三就是一开始提到没有默认构造函数的情况，这里不再赘述…</p>
<h2 id="1-3-初始化列表的初始化顺序"><a href="#1-3-初始化列表的初始化顺序" class="headerlink" title="1.3.初始化列表的初始化顺序"></a>1.3.初始化列表的初始化顺序</h2><p>注意初始化列表的初始化顺序问题：初始化列表是按照声明（成员变量的声明顺序）的先后顺序来依次进行初始化的，与初始化列表的顺序无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a)</span><br><span class="line">        : _a1(a)<span class="comment">//2.由于初始化列表是按照声明的先后顺序来依次进行初始化的</span></span><br><span class="line">        , _a2(_a1)<span class="comment">//3.所以这里的_a2被初始化了随机值，_a1赋予了a的值</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _a1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _a2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//1.下面就是成员变量的声明顺序</span></span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">    <span class="type">int</span> _a2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    aa.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因此这里输出的应该是“1 随机值”</span></span><br></pre></td></tr></table></figure>

<h2 id="1-4-成员变量缺省值"><a href="#1-4-成员变量缺省值" class="headerlink" title="1.4.成员变量缺省值"></a>1.4.成员变量缺省值</h2><p>这点我们之前提到过，在内置成员变量给缺省值的行为实际上是<code>C++</code>对内置类型不处理的补丁，这个缺省值其实是交给初始化列表使用的。</p>
<p>我们可以使用代码并且调试验证一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">        : _i(<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data(int i, int j)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">    <span class="type">int</span> _j = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于是一种隐式的初始化列表，这一点理解很重要。并且如果我们显式和隐式都写出来了，<code>C++</code>默认指挥调用显式的初始化列表，忽略隐式的缺省值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">        : _i(<span class="number">2</span>)</span><br><span class="line">        , _j(<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data(int i, int j)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">    <span class="type">int</span> _j = <span class="number">1</span>;<span class="comment">//该缺省值被忽略</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>私认为：<code>C++构造函数 = 初始化 + 赋值初始值</code>，实际上就是对<code>C</code>语言语句<code>int i = 0;</code>和<code>int i; i = 0;</code>的一种组合，这种设计真的极其精妙。</p>
</blockquote>
<h2 id="1-5-初始化列表和赋值初始值的选择"><a href="#1-5-初始化列表和赋值初始值的选择" class="headerlink" title="1.5.初始化列表和赋值初始值的选择"></a>1.5.初始化列表和赋值初始值的选择</h2><p>结合上面的所有知识，我们会发现<code>C++</code>在这块整得还是挺复杂的，但是最后比较统一的保守的结论是：能使用初始化列表就使用初始化列表，大部分情况下要比直接在函数体内赋值初始化好一些。当然不能一话说到底，有些时候也是需要在函数体内初始化更好，比如对指针的检查…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> N)</span><br><span class="line">        :_a((<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)* N))</span><br><span class="line">        ,_N(N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_a == <span class="literal">NULL</span>)<span class="comment">//这里检查指针并且赋值的过程就不适合全在初始化列表做完了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;malloc fail\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(_a, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* _a;</span><br><span class="line">    <span class="type">int</span> _N;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa0</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-explicit关键字"><a href="#2-explicit关键字" class="headerlink" title="2.explicit关键字"></a>2.explicit关键字</h1><p><code>explicit</code>关键字用于修饰只有一个参数的构造函数，它的作用是防止编译器进行隐式类型转换。具体来说，当使用<code>explicit</code>关键字修饰构造函数时，编译器将不会自动将参数类型转换为类类型，而要求显式地调用该构造函数。</p>
<p>使用<code>explicit</code>关键字的主要目的是避免因隐式类型转换而引发的潜在问题和歧义，以增强代码的可读性和安全性。</p>
<p>上面的一通文字下来是不是没有明白？其实<code>explicit</code>取消了对象使用<code>=</code>初始化的和使用<code>()</code>初始化等价的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> x)</span><br><span class="line">        :_x(x)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data(int x)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data <span class="title">dd1</span><span class="params">(<span class="number">2021</span>)</span></span>;</span><br><span class="line">    Data dd2 = <span class="number">2022</span>;</span><br><span class="line">    <span class="comment">//上述两种写法效果一样，但是过程不一样</span></span><br><span class="line">    <span class="comment">//1.dd1是：“直接调用构造函数构造dd1”</span></span><br><span class="line">    <span class="comment">//2.dd2是：“隐式转化----&gt;2022先调用Data的构造函数，生成了一个临时对象，再使用默认的拷贝构造函数，将临时对象的值赋予dd2”</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是情况2会触发编译器优化</span></span><br><span class="line">    <span class="comment">//“构造函数”+“拷贝构造函数”+“编译器优化”----&gt;“直接调用构造函数”</span></span><br><span class="line">    <span class="comment">//如果在构造函数前面加上explicit关键字，就会取消这种隐式转化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>explicit</code>就会取消这种优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Data</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        :_x(x)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data(int x)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data <span class="title">dd1</span><span class="params">(<span class="number">2021</span>)</span></span>;</span><br><span class="line">    Data dd2 = <span class="number">2022</span>;<span class="comment">//&lt;这里开始报错&gt;</span></span><br><span class="line">    <span class="comment">//上述两种写法效果一样，但是过程不一样</span></span><br><span class="line">    <span class="comment">//1.dd1是：“直接调用构造函数构造dd1”</span></span><br><span class="line">    <span class="comment">//2.dd2是：“隐式转化----&gt;2022先调用Data的构造函数，生成了一个临时对象，再使用默认的拷贝构造函数，将临时对象的值赋予dd2”</span></span><br><span class="line">    <span class="comment">//但是情况2会触发编译器优化</span></span><br><span class="line">    <span class="comment">//“构造函数”+“拷贝构造函数”+“编译器优化”----&gt;“直接调用构造函数”</span></span><br><span class="line">    <span class="comment">//但是我们在构造函数前面加上了explicit关键字，取消这种隐式转化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：如果是有两个成员变量的类呢？怎么使用隐式转化？<code>C++11</code>使用<code>&#123;&#125;</code>来进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Data</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">     : _x(x)</span><br><span class="line">     , _y(y)</span><br><span class="line"> &#123;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;Data(int x)&quot;</span> &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> _x;</span><br><span class="line"> <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> Data&amp; d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Data <span class="title">dd1</span><span class="params">(<span class="number">2021</span>, <span class="number">1212</span>)</span></span>;</span><br><span class="line"> Data dd2 = &#123; <span class="number">2022</span>, <span class="number">1231</span> &#125;;<span class="comment">//有一说一，这不就是数组么？还真不是，这只是初始化了类内的两个成员变量</span></span><br><span class="line"> <span class="type">const</span> Data&amp; dd3 = &#123; <span class="number">3</span>, <span class="number">3</span> &#125;;<span class="comment">//这里引用的是类型为Data的临时变量，如果传递这个临时参数，在VS202的监视窗口就会发现，这里居然传递了一个花括号参数“&#123;_x=3, _y=3&#125;”</span></span><br><span class="line"> <span class="built_in">Function</span>(dd3);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>很多主流的编译器在连续的“构造+拷贝构造”时会进行优化，变成“直接进行构造”，例如：下面代码的运行结果就没有调用拷贝构造函数。</p>
<p>通过下面的<code>8</code>种调用，让我们再细致观察一下这种编译器优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Widget()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        _x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Widget</span>(<span class="type">const</span> Widget&amp; w)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Widget(const Widget&amp; w)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.赋值重载函数</span></span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Widget&amp; w)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Widget&amp; operator=(const Widget&amp; w)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.析构函数</span></span><br><span class="line">    ~<span class="built_in">Widget</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Widget()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(Widget u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Widget <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Widget d; </span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Widget <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Widget</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用1</span></span><br><span class="line">    Widget w1;</span><br><span class="line">    <span class="built_in">f1</span>(w1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//先调用 构造函数Widget()</span></span><br><span class="line">    <span class="comment">//然后调用函数的时候给形参调用 拷贝构造函数Widget(const Widget &amp; w) 拷贝给临时变量u</span></span><br><span class="line">    <span class="comment">//最后调用 析构函数~Widget() 析构掉临时变量u</span></span><br><span class="line">    <span class="comment">//调用2</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="built_in">Widget</span>(<span class="number">2</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原本应该是调用 构造函数Widget() 构造一个匿名对象，</span></span><br><span class="line"><span class="comment">    然后调用 拷贝构造函数Widget(const Widget &amp; w) 拷贝给临时变量u，</span></span><br><span class="line"><span class="comment">    最后使用 析构函数~Widget() 析构掉u。</span></span><br><span class="line"><span class="comment">    但是！由于编译器会优化连续的“构造”+“拷贝构造”----&gt;“直接构造”。</span></span><br><span class="line"><span class="comment">    所以变成下面的调用：</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line">    <span class="comment">//~Widget()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用3</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原本应该是调用 构造函数Widget() 构造一个临时对象，</span></span><br><span class="line"><span class="comment">    然后调用 拷贝构造函数Widget(const Widget &amp; w) 拷贝给临时变量u，</span></span><br><span class="line"><span class="comment">    最后使用 析构函数~Widget() 析构掉u。</span></span><br><span class="line"><span class="comment">    但是！由于编译器会优化连续的“构造”+“拷贝构造”----&gt;“直接构造”。</span></span><br><span class="line"><span class="comment">    所以变成下面的调用：</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line">    <span class="comment">//~Widget()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用4</span></span><br><span class="line">    Widget d2 = <span class="built_in">Widget</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    原本应该是调用 构造函数Widget() 构造一个临时对象，</span></span><br><span class="line"><span class="comment">    然后使用 拷贝构造函数Widget(const Widget &amp; w) 拷贝给d2对象</span></span><br><span class="line"><span class="comment">    但是！由于编译器会优化连续的“构造”+“拷贝构造”----&gt;“直接构造”。</span></span><br><span class="line"><span class="comment">    所以变成下面的调用：</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用5</span></span><br><span class="line">    <span class="built_in">f2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据f(2)的函数内容</span></span><br><span class="line"><span class="comment">    Widget f2()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Widget d; </span></span><br><span class="line"><span class="comment">        return d;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    原本应该是调用 构造函数Widget() 构造d对象，</span></span><br><span class="line"><span class="comment">    然后使用 拷贝构造函数Widget(const Widget &amp; w) 交给一个临时变量便于返回函数值</span></span><br><span class="line"><span class="comment">    最后析构这个临时变量</span></span><br><span class="line"><span class="comment">    但是！由于编译器会优化连续的“构造”+“拷贝构造”----&gt;“直接构造”。</span></span><br><span class="line"><span class="comment">    所以变成下面的调用：</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line">    <span class="comment">//~Widget()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用6</span></span><br><span class="line">    Widget ret1 = <span class="built_in">f2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据f(2)的函数内容</span></span><br><span class="line"><span class="comment">    Widget f2()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Widget d; </span></span><br><span class="line"><span class="comment">        return d;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    原本应该是调用 构造函数Widget() 构造d对象，</span></span><br><span class="line"><span class="comment">    然后使用 拷贝构造函数Widget(const Widget &amp; w) 将d拷贝给一个临时对象便于返回函数值，</span></span><br><span class="line"><span class="comment">    再调用 拷贝构造函数Widget(const Widget &amp; w) 将临时对象拷贝给ret1</span></span><br><span class="line"><span class="comment">    然后析构这个临时变量。</span></span><br><span class="line"><span class="comment">    这里编译器直接不生成临时变量，将d直接调用 拷贝构造函数Widget(const Widget &amp; w) 给ret1。</span></span><br><span class="line"><span class="comment">    再由于编译器会优化连续的“构造”+“拷贝构造”----&gt;“直接构造”，</span></span><br><span class="line"><span class="comment">    因此在 Widget ret1 = f2(); 这一句的调用中就只剩下了“直接构造”。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用7</span></span><br><span class="line">    Widget ret2;</span><br><span class="line">    ret2 = <span class="built_in">f2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先使用 构造函数Widget() 构造一个ret2对象</span></span><br><span class="line"><span class="comment">    然后在f2()内调用 构造函数Widget() 构造d对象，</span></span><br><span class="line"><span class="comment">    然后使用 拷贝构造函数Widget(const Widget &amp; w) 将d拷贝给一个临时对象便于返回函数值，</span></span><br><span class="line"><span class="comment">    再使用 赋值重载函数Widget&amp; operator=(const Widget&amp; w) 将临时变量赋值给ret2，</span></span><br><span class="line"><span class="comment">    最后析构临时变量。</span></span><br><span class="line"><span class="comment">    由于不是在一行代码内连续构造析构，所以这里编译器只优化了部分（在f2()内的构造和拷贝构造变成了直接构造），没有全部优化。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line">    <span class="comment">//Widget&amp; operator=(const Widget &amp; w)</span></span><br><span class="line">    <span class="comment">//~Widget()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用8</span></span><br><span class="line">    Widget ret3 = <span class="built_in">f3</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据f3()内部构造：</span></span><br><span class="line"><span class="comment">    Widget f3()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return Widget(1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    原本先是调用 构造函数 构造一个匿名对象，</span></span><br><span class="line"><span class="comment">    然后通过 拷贝构造函数 将匿名对象拷贝给临时对象，</span></span><br><span class="line"><span class="comment">    然后使用 拷贝构造函数 将临时变量拷贝给ret3，</span></span><br><span class="line"><span class="comment">    最后由于优化就变成了下面这样：</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//Widget()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了提高效率，有的时候也会把大量的构造写到一起，触发编译器的优化。（但是如果编译器优化得过于激进，有可能带来调试上的不方便），在这里推荐看书《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/10427315/">深度探索C++对象模型</a>》。</p>
<blockquote>
<p>注意：主流的编译器都会进行这种优化，但是这不是<code>C++</code>标准规定的！</p>
</blockquote>
<h1 id="3-static成员变量"><a href="#3-static成员变量" class="headerlink" title="3.static成员变量"></a>3.static成员变量</h1><h2 id="3-1-static成员的引入"><a href="#3-1-static成员的引入" class="headerlink" title="3.1.static成员的引入"></a>3.1.static成员的引入</h2><p>让我们先进入一个场景，我们可能需要统计创建对象和正在使用对象的个数<code>n</code>和<code>m</code>，我们可以写出下面这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//累积创建了n个对象</span></span><br><span class="line"><span class="comment">//累积使用了m个对象</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Data <span class="title">Func</span><span class="params">(Data a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d1;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    Data d2;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Data</span> ();</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Func</span>(d2);</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在运行代码的过程中，可能会不小心篡改了<code>n</code>和<code>m</code>的数据，导致最后的数据不正确。</p>
<p>因此我们需要另外一种解决方案，<code>static</code>成员变量。</p>
<p>声明为<code>static</code>的类成员被称为类的静态成员。</p>
<ol>
<li><p>用<code>static</code>修饰的成员变量，称之为静态成员变量</p>
</li>
<li><p>用<code>static</code>修饰的成员函数，称之为静态成员函数</p>
</li>
</ol>
<p>静态成员变量一定要在类的外面进行初始化，不可以使用构造函数的初始化列表来初始化。</p>
<blockquote>
<p>  补充：但是有一种特殊情况是可以在类内初始化的。</p>
<p>  就是带<code>const</code>修饰的静态成员变量有缺省值：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;<span class="comment">//成功</span></span><br><span class="line">   <span class="comment">//static int b = 2;//失败</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  但是又不能在初始化列表内初始化：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">A</span>(<span class="type">int</span> number = <span class="number">1</span>)</span><br><span class="line">       : <span class="built_in">a</span>(number)<span class="comment">//失败</span></span><br><span class="line">   &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="3-2-static成员的特性"><a href="#3-2-static成员的特性" class="headerlink" title="3.2.static成员的特性"></a>3.2.static成员的特性</h2><ol>
<li><p>静态成员变量为所有相同类的对象所共享，其不属于某个具体的对象，存放在静态区（静态变量没有办法在类内给与缺省值，这是因为缺省值是交给某个对象的构造函数的初始化列表的。但是静态成员变量是属于所有相同类型的对象的。并且在计算对象的大小的时候也不会将其计入计算）</p>
</li>
<li><p>静态成员变量必须在类外定义，定义时不用添加<code>static</code>关键字，类中的只是声明。其定义的方式有点类似函数的定义方式</p>
</li>
<li><p>静态成员函数没有隐藏的<code>this</code>指针，不能直接访问任何非静态成员（但是非静态成员函数可以访问所有的成员变量，包括静态成员变量）</p>
</li>
<li><p>类静态成员可用<code>类名::静态成员</code>或者<code>对象.静态成员</code>两种方式来访问，因为静态成员变量属于类域</p>
</li>
<li><p>静态成员也是类的成员，也受访问限定符的限制</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//累积创建了n个对象</span></span><br><span class="line"><span class="comment">//累积使用了m个对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Data::n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Data::m = <span class="number">0</span>;</span><br><span class="line"><span class="function">Data <span class="title">Func</span><span class="params">(Data a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d1;</span><br><span class="line">    cout &lt;&lt; Data::n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d1.m &lt;&lt; endl;</span><br><span class="line">    Data d2;</span><br><span class="line">    cout &lt;&lt; d1.n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Data::m &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Data</span> ();</span><br><span class="line">    cout &lt;&lt; Data::n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Data::m &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Func</span>(d2);</span><br><span class="line">    cout &lt;&lt; d2.n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d2.m &lt;&lt; endl;</span><br><span class="line">    Data* d3 = <span class="literal">nullptr</span>;</span><br><span class="line">    cout &lt;&lt; d3-&gt;n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d3-&gt;m &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再修改一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//累积创建了n个对象</span></span><br><span class="line"><span class="comment">//累积使用了m个对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">const</span> Data&amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Data</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Data::n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> Data::m = <span class="number">0</span>;</span><br><span class="line"><span class="function">Data <span class="title">Func</span><span class="params">(Data a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d1;</span><br><span class="line">    d1.<span class="built_in">Print</span>();</span><br><span class="line">    Data d2;</span><br><span class="line">    Data::<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">Data</span> ();</span><br><span class="line">    Data::<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">Func</span>(d2);</span><br><span class="line">    Data::<span class="built_in">Print</span>();</span><br><span class="line">    Data* d3 = <span class="literal">nullptr</span>;</span><br><span class="line">    d3-&gt;<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-static成员的场景"><a href="#3-3-static成员的场景" class="headerlink" title="3.3.static成员的场景"></a>3.3.static成员的场景</h2><h3 id="3-3-1-计算1-2-…-n-1-n的值"><a href="#3-3-1-计算1-2-…-n-1-n的值" class="headerlink" title="3.3.1.计算1+2+…+(n-1)+n的值"></a>3.3.1.计算1+2+…+(n-1)+n的值</h3><p>这里有一道牛客题目可以试着做一下，下面的代码使用<code>new</code>，<code>new</code>的作用类似<code>malloc</code>，如果看不懂可以暂且跳过，等您知道<code>C++</code>的内存管理就能明白。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sum</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sum</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _ret += _i;</span><br><span class="line">        _i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetRet</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _i;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _ret;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Sum::_i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> Sum::_ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sum* arr = <span class="keyword">new</span> Sum[n];</span><br><span class="line">        <span class="keyword">return</span> Sum::<span class="built_in">GetRet</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-创建只能在栈上开辟的类"><a href="#3-3-2-创建只能在栈上开辟的类" class="headerlink" title="3.3.2.创建只能在栈上开辟的类"></a>3.3.2.创建只能在栈上开辟的类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> B <span class="title">CreateObj</span><span class="params">()</span><span class="comment">//3.提供一个接口，来间接使用构造函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        B b;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>)<span class="comment">//2.在构造的时候只能在栈上开辟空间，否则无法使用类，因为这里访问限定符是private</span></span><br><span class="line">        : _x(x)</span><br><span class="line">        , _y(y)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//static B data1;//1.无法创建，因为构造函数是私有的</span></span><br><span class="line">    B data2 = B::<span class="built_in">CreateObj</span>();<span class="comment">//4.依靠接口间接创建了data2对象，并且保证一定是在栈上开辟（因此没有办法再堆上开辟该类型的对象）</span></span><br><span class="line">    <span class="comment">//5.CreateObj前面之所以加上static</span></span><br><span class="line">    <span class="comment">//是为了避免“先有鸡，还是先有蛋”的问题</span></span><br><span class="line">    <span class="comment">//因为假设没有static，要使用CreateObj()就要先创建一个B类型的对象才能使用</span></span><br><span class="line">    <span class="comment">//但是由于限定符private的原因没有办法直接使用构造函数创建变量</span></span><br><span class="line">    <span class="comment">//使得能够直接使用CreateObj()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-friend友元"><a href="#4-friend友元" class="headerlink" title="4.friend友元"></a>4.friend友元</h1><p>之前在上半篇部分的日期类里，有用过一点友元的知识，本次我将带您真正了解友元的知识。</p>
<p>友元的关键字是<code>friend</code>，友元提供了一种突破封装的方式，有时候会比较便利，也有的时候会破坏封装，友元是不建议过多使用的。 友元又分为“友元函数”和“友元类”。 </p>
<h2 id="4-1-友元函数"><a href="#4-1-友元函数" class="headerlink" title="4.1.友元函数"></a>4.1.友元函数</h2><ol>
<li><p>友元函数可以访问类的私有和保护成员，但不是类的成员函数</p>
</li>
<li><p>友元函数不能用<code>const</code>修饰<code>this</code>（这点和静态函数一样，因为两者都没有<code>this</code>指针）</p>
</li>
<li><p>友元函数可以在类定义的任何地方声明，不受类访、问限定符限制</p>
</li>
<li><p>一个函数可以是多个类的友元函数</p>
</li>
<li><p>友元函数的调用与普通函数的调用原理相同</p>
</li>
</ol>
<p>在<code>C++</code>中，<code>const</code>成员函数的目的是确保在函数内部不会修改对象的状态，并且它们具有一个隐含的<code>this</code>指针类型为<code>const</code>指针。这意味着在<code>const</code>成员函数内部，对象被视为常量，不能通过<code>this</code>指针对其进行修改。</p>
<p>然而，在友元函数中，由于友元函数不属于类的成员函数，不存在<code>this</code>指针。因为友元函数不连接到任何特定的对象，无法访问对象的成员变量或成员函数，也无法使用<code>this</code>指针来引用对象。</p>
<p>由于没有<code>this</code>指针的存在，我们无法在友元函数中使用<code>const</code>来限定该函数。<code>const</code>关键字用于修饰隐含的<code>this</code>指针，但由于友元函数没有<code>this</code>指针，所以使用<code>const</code>是无效的。</p>
<p>因此，因为友元函数不是类的成员函数且没有<code>this</code>指针，我们不能在友元函数中使用<code>const</code>修饰符。友元函数可以自由地修改对象的成员，包括私有成员，而不受<code>const</code>的限制（这还是很恐怖的，因此能别用就别用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">void</span>)</span></span>;<span class="comment">//1.把function()设置为Data类的友元函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>, <span class="type">int</span> c = <span class="number">0</span>)</span><br><span class="line">        :_a(a), _b(b), _c(c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data D;</span><br><span class="line">    cout &lt;&lt; D._a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; D._b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; D._b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;<span class="comment">//2.可以访问Data对象受保护的成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-友元类"><a href="#4-2-友元类" class="headerlink" title="4.2.友元类"></a>4.2.友元类</h2><ol>
<li><p>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员</p>
</li>
<li><p>友元关系是单向的，不具有交换性（<code>A</code>是<code>B</code>的友元类，但是<code>B</code>不是<code>A</code>的友元类）</p>
</li>
<li><p>友元关系不具有传递性（<code>C</code>是<code>B</code>的友元，<code>B</code>是<code>A</code>的友元，但是<code>C</code>不是<code>A</code>的友元）</p>
</li>
<li><p>友元关系不能继承，在以后讲解继承的时候再做补充，这里讲还是太早了</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">FriendData</span>;<span class="comment">//1.给Data类设置了友元类FriendData</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>, <span class="type">int</span> c = <span class="number">0</span>)</span><br><span class="line">        :_a(a), _b(b), _c(c)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">    <span class="type">int</span> _b;</span><br><span class="line">    <span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FriendData</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Data D;</span><br><span class="line">        cout &lt;&lt; D._a &lt;&lt; endl;<span class="comment">//2.可以毫无顾忌访问Data对象中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Data D;</span><br><span class="line">        cout &lt;&lt; D._a &lt;&lt; endl;<span class="comment">//3.除了变量还能访问Data对象中的成员函数</span></span><br><span class="line">        D.<span class="built_in">Print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Data D;</span><br><span class="line">        cout &lt;&lt; D._a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data D;</span><br><span class="line">    cout &lt;&lt; D._a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; D._b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; D._b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">    D.<span class="built_in">Print</span>();</span><br><span class="line">    FriendData FD;</span><br><span class="line">    FD.<span class="built_in">Fun1</span>();</span><br><span class="line">    FD.<span class="built_in">Fun2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h1><p>把一个类定义另外一个类里面，就叫“内部类”，<code>Java</code>会用的比较多，但是<code>C++</code>会比较少，内部类天生是外部类的友元类。</p>
<p>内部类可以无限制访问外部类的公有、私有成员变量，外部类无法访问内部类的私有成员变量（这就是友元类的体现）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">    <span class="comment">//2.Data2定义在Data1内部，仅仅只是：</span></span><br><span class="line">    <span class="comment">//2.1.被A的限定符限制</span></span><br><span class="line">    <span class="comment">//2.2.Data2天生是Data1的友元类</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">(<span class="type">const</span> Data1&amp; a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; a._a1 &lt;&lt; endl;<span class="comment">//3.友元的体现</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> _a2;</span><br><span class="line">        <span class="type">int</span> _b2;</span><br><span class="line">        <span class="type">int</span> _c2;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a1;</span><br><span class="line">    <span class="type">int</span> _b1;</span><br><span class="line">    <span class="type">int</span> _c1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Data1) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//1.输出12，说明Data1没有计算Data2大小</span></span><br><span class="line">    Data1::Data2 D;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面的<code>sizeof</code>输出，可以得出结论：抛去“类域限制”和“天生友元”，基本外部类和内部类在地位关系上可以认为是并列的，并不是包含关系！</p>
<p>上面我们曾经写过牛客的一道题目，我们可以试着使用内部类以及友元的知识改造一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Sum</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Sum</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            _ret += _i;</span><br><span class="line">            _i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sum* arr = <span class="keyword">new</span> Sum[n];</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _i;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _ret;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Solution::_i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> Solution::_ret = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="6-匿名对象"><a href="#6-匿名对象" class="headerlink" title="6.匿名对象"></a>6.匿名对象</h1><p><code>C++</code>还可以创建一个匿名对象，匿名对象的生命周期只有一行，除非使用引用延长生命周期。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Data</span>(<span class="number">8</span>);<span class="comment">//这就是一个匿名对象，只可以在这一行被使用，没有标识符</span></span><br></pre></td></tr></table></figure>

<p>匿名对象有什么作用呢？目前我们对于<code>C++</code>的运用还是太少了，以后我们会发现匿名对象的使用场景还是很多的。</p>
<ol>
<li><p>匿名对象直接传参可以简化部分代码</p>
</li>
<li><p>有的时候如果为了调用某个函数创建一个有名对象未免过于繁琐</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">0</span>)</span><br><span class="line">        : _x(x)</span><br><span class="line">        , _y(y)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(Data a, Data b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; a._x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a._y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; b._x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b._y &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d1;</span><br><span class="line">    d1.<span class="built_in">Print</span>(<span class="built_in">Data</span>(<span class="number">100</span>, <span class="number">100</span>), <span class="built_in">Data</span>(<span class="number">32</span>, <span class="number">123</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名对象具有常属性，不能被直接引用，但是可以被<code>const</code>引用，这种引用会延长匿名对象的生命周期。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"><span class="type">const</span> Data&amp; d = <span class="built_in">Data</span>();<span class="comment">//后续代码就可以使用d来使用匿名对象，这和直接定义一个Data对象没有什么太大区别</span></span><br></pre></td></tr></table></figure>

<p>实际上上面就是使得匿名对象变成有名对象的过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/01/3-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="limou3434">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/01/3-C-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%EF%BC%88%E4%B8%8A%EF%BC%89/" itemprop="url">3.C++类的基本概述（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-01T18:09:48+08:00">
                2023-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-面向过程和对象"><a href="#1-面向过程和对象" class="headerlink" title="1.面向过程和对象"></a>1.面向过程和对象</h1><h2 id="1-1-面向过程"><a href="#1-1-面向过程" class="headerlink" title="1.1.面向过程"></a>1.1.面向过程</h2><p><code>C</code>语言就是一种面向过程的语言，如果您经常使用<code>C</code>解决问题，就会发现在编程的过程中我们非常注重细节和步骤，通过各种块级功能的函数调用逐步解决问题。</p>
<h2 id="1-2-面向对象"><a href="#1-2-面向对象" class="headerlink" title="1.2.面向对象"></a>1.2.面向对象</h2><p><code>C++</code>语言，是面向对象和面向过程的一种混编语言，在解决问题时，关注的是对象，将一件事情拆分为不同的对象，靠对象之间的交互完成。</p>
<blockquote>
<p>例子：我想煮饭，于是需要对象：我、电饭煲、菜，“我”把“菜”放入“电饭锅”，不需要了解我是通过哪一块肌肉放入菜，不需要了解菜是具有什么分子结构，不需要了解电饭煲的工作原理，煮饭都是靠“我”、“菜”、“电饭煲”三者（三个对象）交互完成的。</p>
</blockquote>
<h1 id="2-类的引入"><a href="#2-类的引入" class="headerlink" title="2.类的引入"></a>2.类的引入</h1><h2 id="2-1-类和结构"><a href="#2-1-类和结构" class="headerlink" title="2.1.类和结构"></a>2.1.类和结构</h2><p><code>C</code>语言的结构体只能定义变量，而结构体不仅可以定义变量，也可以定义函数。</p>
<p>但是对于结构体在内部加入函数的方式，<code>C++</code>更喜欢用<code>class</code>来代替<code>struct</code>。</p>
<p>使用<code>struct</code>是为了和<code>C</code>兼容使用。</p>
<h2 id="2-2-类的使用"><a href="#2-2-类的使用" class="headerlink" title="2.2.类的使用"></a>2.2.类的使用</h2><p>下面我们在<code>C++</code>代码中使用<code>struct</code>来定义一个基础的<code>C++</code>类&#x2F;结构体（在<code>C++</code>中结构体被升级了，不仅可以放入成员变量，还可以放入成员函数的定义或者声明）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类和对象的使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Xadd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//C++的结构体是升级版本的结构体</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * x + b * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str X;</span><br><span class="line">    X.a = <span class="number">2</span>;</span><br><span class="line">    X.b = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, X.<span class="built_in">Xadd</span>(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//调用成员变量或者成员函数，都可以使用“.”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//而且C++的结构体名可以省略struct的写法</span></span><br></pre></td></tr></table></figure>

<p>在<code>C++</code>里最为标准的类的写法是使用<code>class</code>（也就是<code>struct</code>的升级版，功能更加强大，至于强大在哪里我们后续会提及）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类和对象的使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Xadd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//C++的结构体是升级版本的结构体</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * x + b * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str X;</span><br><span class="line">    X.a = <span class="number">2</span>;<span class="comment">//出错</span></span><br><span class="line">    X.b = <span class="number">5</span>;<span class="comment">//出错</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, X.<span class="built_in">Xadd</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>class</code>是定义类的关键字，后面跟着类的名字，即“类名”，<code>&#123;&#125;</code>中为类的成员</p>
</li>
<li><p>类中的变量称为类的属性（成员变量）</p>
</li>
<li><p>类中的函数称为类的方法（成员函数）</p>
</li>
</ol>
<p>但是这么写为什么没有办法运行呢？这是因为类还有三个限定符，分别是：<code>public</code>（公有）、<code>protected</code>（保护）、<code>private</code>（私有），在没有使用限定符的情况下，类默认其成员是私有的（不可以被外界访问），但是结构体默认其成员是公有的（这是为了兼容<code>C</code>的<code>struct</code>）。</p>
<p>在<code>C</code>中，<code>stack</code>结构体可以创建出一个结构体变量，<code>C++</code>的<code>class</code>类也同样可以，但是需要注意的是，由类创建出来的变量不是被称为“类变量”，而被称做“对象”。</p>
<p>通过对象可以像以前的结构体变量一样访问成员变量，甚至是调用成员函数（例如：上面<code>C++</code>代码中的<code>X.Xadd(1, 2)</code>就是通过<code>X</code>这个对象来调用成员函数<code>Xadd()</code>的）。</p>
<blockquote>
<p>补充：命名方法规范</p>
<p>在<code>C++</code>中，有一些常见的命名方法，我们整篇系列的命名以大小驼峰法来命名。</p>
<ol>
<li><p>函数名、类名大驼峰</p>
</li>
<li><p>普通变量小驼峰</p>
</li>
<li><p>成员变量首单词从<code>_</code>开始</p>
</li>
</ol>
</blockquote>
<h2 id="2-3-类限定符"><a href="#2-3-类限定符" class="headerlink" title="2.3.类限定符"></a>2.3.类限定符</h2><p>在了解类限定符之前，我们先来了解一下面向对象语言三大特性之一的“封装”。</p>
<h3 id="2-3-1-类封装的概念"><a href="#2-3-1-类封装的概念" class="headerlink" title="2.3.1.类封装的概念"></a>2.3.1.类封装的概念</h3><p>面向对象的三大特性：封装、继承、多态（这三个是最重要的，但是面向对象还有其他的特性，例如“抽象”）。封装的本质是以一种管理，封装将数据和操作数据的方法结合起来，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。</p>
<p>封装让用户更加方便使用类。而<code>C++</code>通过访问限定符来控制隐藏对象的细节，控制哪些方法可以在类外部直接使用。</p>
<h3 id="2-3-2-限定符的使用"><a href="#2-3-2-限定符的使用" class="headerlink" title="2.3.2.限定符的使用"></a>2.3.2.限定符的使用</h3><ol>
<li><p><code>public</code>（公有），<code>public</code>修饰的成员在类外可以直接被访问</p>
</li>
<li><p><code>protected</code>（保护），<code>protected</code>和<code>private</code>修饰的成员在类外不能直接被访问（此处<code>protected</code>和<code>private</code>是类似的）</p>
</li>
<li><p><code>private</code>（私有），<code>protected</code>和<code>private</code>修饰的成员在类外不能直接被访问（此处<code>protected</code>和<code>private</code>是类似的）</p>
</li>
</ol>
<blockquote>
<p>补充：</p>
<p><code>public</code>成员在类内外均可访问，<code>protected</code>成员只能在类内和派生类中访问，而<code>private</code>成员仅能在类内访问。<br>三个关键字的范围是从使用访问限定符开始，直到遇到另外一个访问限定符这类的<code>&#125;</code>结尾时结束。<br><code>protected</code>和<code>private</code>在后面讲到继承的时候才能进一步做区分。</p>
</blockquote>
<p>而访问限定符的作用范围从该访问限定符出现的位置开始直到下一个访问限定符出现为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类和对象的使用</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">str</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Xadd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span><span class="comment">//C++的结构体是升级版本的结构体</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        b = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> a * x + b * y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    str X;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, X.<span class="built_in">Xadd</span>(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：访问限定符只有在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别。</p>
</blockquote>
<p>在没有见到继承等概念之前，我们的<code>C++</code>程序会出现大量的<code>public</code>和<code>private</code>这两个限定符，您只需要重点了解这两个就行。</p>
<h2 id="2-4-类作用域"><a href="#2-4-类作用域" class="headerlink" title="2.4.类作用域"></a>2.4.类作用域</h2><p>类的出现赋予了<code>C++</code>一个新得作用域：类的作用域，即“类域”。</p>
<ol>
<li><p>在类的里面，类的所有成员都在类的作用域中</p>
</li>
<li><p>在类外面定义成员时，需要使用<code>::</code>作用域操作符来指明</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPersonInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> _gender[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span>  _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里需要指定PrintPersonInfo是属于Person这个类域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintPersonInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _gender &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，哪怕有访问限定符，只要使用的是同属一个类内的函数或遍历，就不受限定符的影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _a = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(A x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x._a &lt;&lt; endl;<span class="comment">//这里没有报错，说明同类的使用是不会被访问限定符限定的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Prin</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A x;</span><br><span class="line">    A y;</span><br><span class="line">    x.<span class="built_in">f1</span>(<span class="number">2</span>);</span><br><span class="line">    y.<span class="built_in">f1</span>(<span class="number">3</span>);</span><br><span class="line">    x.<span class="built_in">Prin</span>();</span><br><span class="line">    y.<span class="built_in">Prin</span>();</span><br><span class="line">    y.<span class="built_in">f2</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且编译器在类里面会上下搜索，不是按照向上查找的方式编译代码。</p>
<h2 id="2-5-类的定义"><a href="#2-5-类的定义" class="headerlink" title="2.5.类的定义"></a>2.5.类的定义</h2><h3 id="2-5-1-类中定义函数"><a href="#2-5-1-类中定义函数" class="headerlink" title="2.5.1.类中定义函数"></a>2.5.1.类中定义函数</h3><p>声明放在类中，定义也放在类中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//某些方法（包括声明和定义）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//某些属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果成员函数在类中直接定义，编译器可能当成内联函数处理。因此可以利用这一点，较小的函数若要做内联，则直接写到类内部。</p>
<h3 id="2-5-2-类外定义函数"><a href="#2-5-2-类外定义函数" class="headerlink" title="2.5.2.类外定义函数"></a>2.5.2.类外定义函数</h3><p>声明放在类中，定义放在类外。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类头文件class.h中</span></span><br><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//某些方法基本信息（函数声明）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//某些属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类源文件class.c中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;class.h&quot;</span> </span></span><br><span class="line">函数返回值 类名::函数名字() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//某些方法定义（函数方法） </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说后者会比较规范一些（就是需要注意一些语法细节），但为了更加好演示代码，后续的文章大部分采用第一种，正式工作时能用第二种就用第二种。</p>
<p>而且可以尝试区分好方法名字和属性名字，比如在属性（类里的成员变量）前加上下划线<code>_</code>、函数名&#x2F;类名采用大驼峰命名、变量名采用小驼峰命名。</p>
<h2 id="2-6-类实例化"><a href="#2-6-类实例化" class="headerlink" title="2.6.类实例化"></a>2.6.类实例化</h2><p>使用类创建对象的过程，被称为类的实例化。简单来说：类只是一份构建对象的图纸，在创建对象的时候，编译器会根据对象对应的类结构来给对象开辟应有的空间，这个过程就是“实例化”。</p>
<ol>
<li><p>类是给对象（您可以理解为一个结构体&#x2F;类创建出来的一个变量）进行描述，是对象的一个模板，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它（也就是说类的成员可以说是一种类似“声明”的存在，而不是定义）</p>
</li>
<li><p>类可以实例化（也就是类的定义）出多个对象来，实例化出的对象会占有实际的物理空间，也就是定义</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPersonInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> _name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> _gender[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span>  _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintPersonInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _gender &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person._age = <span class="number">10</span>;   <span class="comment">// 编译失败：error C2059: 语法错误:“.”，因为没有对</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确做法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintPersonInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span>* _name;</span><br><span class="line">    <span class="type">char</span>* _sex;</span><br><span class="line">    <span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Person::PrintPersonInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _sex &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person man;</span><br><span class="line">    man._name = (<span class="type">char</span>*)<span class="string">&quot;limou3434&quot;</span>;<span class="comment">//由于C++类型检查比较严格，故加上强制转化</span></span><br><span class="line">    man._age = <span class="number">10</span>;</span><br><span class="line">    man._sex = (<span class="type">char</span>*)<span class="string">&quot;男&quot;</span>;<span class="comment">//由于C++类型检查比较严格，故加上强制转化</span></span><br><span class="line">    man.<span class="built_in">PrintPersonInfo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-7-对象大小"><a href="#2-7-对象大小" class="headerlink" title="2.7.对象大小"></a>2.7.对象大小</h2><p>如果一个类中既有成员变量又有成员函数，那么这个根据类结构创建出来的对象的大小是多少呢？需要加上成员函数的大小吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类中既有成员变量，又有成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中仅有成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类中什么都没有---空类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A3</span></span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为4 1 1</span></span><br></pre></td></tr></table></figure>

<p>实际就是该类中“成员变量”之和，不过要注意内存对齐的问题！这点和结构体内存对齐是一样的…因此我们可以观察到：对象在计算大小中是不算上成员函数的。</p>
<p>为什么不带上成员函数的大小呢？不带上的话，函数需要的空间又应该保存在哪里呢？让我们假设下面三种情况：</p>
<ol>
<li><p>对象存储方法一：存储“类函数+类成员变量”假设大小含有成员函数，那么每次都实例化一个类生成一个对象时，就会重复多出函数的栈帧空间，浪费空间</p>
</li>
<li><p>对象存储方法二：存储“类函数表地址+类成员变量”，其中类函数表地址指向一个类函数表（这在虚表和多态被采用），这种方案不错，但是<code>C++</code>没有采用这种</p>
</li>
<li><p>对象存储方法三：只保存成员变量，成员函数存放在公共的代码段。编译链接的时候就会根据函数名去公共代码区找到函数的地址（类似<code>a.Function()</code>时，汇编的时候会使用<code>call</code>指令去替换，即：<code>call</code>函数地址），这是<code>C++</code>所采用的</p>
</li>
</ol>
<blockquote>
<p>注意：类成员函数表（<code>Class Member Function Table</code>）和公共代码区域（<code>Common Code Area</code>）是两个不同的概念。</p>
<ol>
<li><p>类成员函数表：类成员函数表是用于存储与类相关的成员函数指针的数据结构。每当创建一个类的对象时，都会为该类分配一个内存空间，并在内存中创建一个类成员函数表。类成员函数表中的每个条目都保存着对应成员函数的地址。通过类成员函数表，可以在运行时动态地调用类的成员函数。这种机制称为虚函数表（<code>VTable</code>）或虚函数指针表（<code>VPointer Table</code>），它支持面向对象编程中的多态性。</p>
</li>
<li><p>公共代码区域：公共代码区域是指程序中多个模块（例如函数、方法或类）之间共享的代码部分。当多个模块需要访问相同的功能或过程时，它们可以共享一段代码，而不是复制相同的代码到每个模块中。这样做可以减少冗余，并提高代码的重用性和可维护性。公共代码区域通常位于内存的某个特定位置，所有需要访问这些公共代码的模块都可以通过指针或跳转进行调用。</p>
</li>
</ol>
<p>总结起来，类成员函数表是一个与类相关的数据结构，用于支持多态调用类的成员函数。而公共代码区域则是指多个模块之间共享的代码部分，可以提高代码的重用性和可维护性。两者是面向对象编程和模块化设计中不同概念的体现。</p>
</blockquote>
<p>使用下面代码也能证明：函数没有在类中存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">Print</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">A::Print</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Helow word!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    A* ptr = nullptr;</span><br><span class="line">    ptr-&gt;Print();<span class="comment">//正常运行，因为这里不是真正的解引用，原因是function()函数没有真正放在类中，而是放在了公共代码区，这里只是单纯的调用罢了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外这里需要注意空类（没有任何成员函数和成员变量的类）的大小，空类比较特殊，<code>C++</code>规定空类使用一个字节大小的空间来唯一标识这个类的对象，只做占位使用，内部不存储实际数据。<br>为什么说是做标记使用呢？因为如果开辟<code>0</code>字节，那就没有指针可以指向这个空间了，下面两个对象就无法做出区分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;&#125;;<span class="comment">//空类</span></span><br><span class="line">Data d1;<span class="comment">//空类创建出来的成员1</span></span><br><span class="line">Data d2;<span class="comment">//空类创建出来的成员2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zd&quot;</span>, <span class="built_in">sizeof</span>(Data));<span class="comment">//输出1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;d1);<span class="comment">//d1和d2存储在两个地方</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>, &amp;d2);</span><br></pre></td></tr></table></figure>

<h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3.this指针"></a>3.this指针</h1><p>我们之前说过，类是创建对象的一个“模板”，但是在类中存在成员函数，并且我们通过对象来调用成员函数的时候，有一个很奇怪的现象。</p>
<h2 id="3-1-隐藏this指针"><a href="#3-1-隐藏this指针" class="headerlink" title="3.1.隐藏this指针"></a>3.1.隐藏this指针</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span><span class="comment">//3.但是函数是怎么找到实例化后，变量里的_year呢？其实就是在这里的参数列表隐藏了一个this指针（每一个成员函数都有）完整写法为：void Init(Date* const this, int year, int month, int day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;<span class="comment">//2.而这里的year值并不是赋给了类里的_year，而是实例化后对象d里的_year，这句话的完整写法为：this-&gt;_year = year;</span></span><br><span class="line">        _month = month;<span class="comment">//这句话的完整写法为：this-&gt;_month= month;</span></span><br><span class="line">        _day = day;<span class="comment">//这句话的完整写法为：this-&gt;_day= day;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;<span class="comment">//1.没有经过实例化的类，因此这里的_year只是声明</span></span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data::Print</span><span class="params">(<span class="type">void</span>)</span><span class="comment">//这里没有添加this指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;<span class="comment">//这个函数到底打印的是哪一个对象的成员变量？？？</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d;</span><br><span class="line">    d.<span class="built_in">Init</span>(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    d.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code>指针参数由编译器帮我们加上，在对象<code>d</code>调用函数<code>Init()</code>的时候，函数参数内部隐含一个<code>this</code>指针参数，指向对象<code>d</code>，确保初始化的对象是<code>d</code>的成员变量。</p>
<p>但是在类外定义的函数不会自动添加<code>this</code>指针，因此调用<code>Print()</code>函数的时候，函数的参数列表内部没有隐藏的<code>this</code>指针，因此不知道指向哪一个对象，这样在打印成员变量的时候，该函数就会失败。</p>
<p>下面为了方便理解，我们把编译器的活也给补上（注意下面的代码是运行不起来的，只是我们演示了在编译器视角是怎么工作的）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Data</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    void Init(Date* const this, int year, int month, int day)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        this-&gt;_year = year;</span></span><br><span class="line"><span class="comment">        this-&gt;_month = month;</span></span><br><span class="line"><span class="comment">        this-&gt;_day = day;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void Print();</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">    int _year;</span></span><br><span class="line"><span class="comment">    int _month;</span></span><br><span class="line"><span class="comment">    int _day;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">void Data::Print()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Data d;</span></span><br><span class="line"><span class="comment">    d.Init(&amp;d1, 2023, 6, 8);</span></span><br><span class="line"><span class="comment">    d.Print(&amp;d1);</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-显示this指针"><a href="#3-2-显示this指针" class="headerlink" title="3.2.显示this指针"></a>3.2.显示this指针</h2><p><code>this</code>指针我们不能手动加到函数参数列表，或者函数调用中（即：不能显示接受和显示传递<code>this</code>指针），这是编译器在做的事情，编译器会帮您自动加上。</p>
<p>但是有一个例外：您可以在函数内部使用<code>this</code>指针，这点<code>C++</code>没做太多限制，唯一需要的是由于<code>this</code>指针参数的类型是<code>类类型 const*</code>，因此没有办法使用解引用改变<code>this</code>指向对象的值。</p>
<p>这种情况经常出现在类外部定义的函数，由于声明在类内部，因此已经添加了<code>this</code>指针，定义处的参数列表也不需要再声明有一个<code>this</code>指针的存在，但是函数定义内的函数体没有自动添加<code>this</code>指针，需要我们手动加上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_year = year;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_month = month;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data::Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;_year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;_month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;_day &lt;&lt; endl;<span class="comment">//手动调用，这里的this是我们自己写出来的，不是编译器加上来的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d;</span><br><span class="line">    d.<span class="built_in">Init</span>(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    d.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-this指针的特性"><a href="#3-3-this指针的特性" class="headerlink" title="3.3.this指针的特性"></a>3.3.this指针的特性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span><span class="comment">//2.程序来到这里后，这里的函数头等价于“Print(Cl* const this)”</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;<span class="comment">//3.上面这一句展开来写就是“cout &lt;&lt; this-&gt;x &lt;&lt; endl;”这个时候就发生空指针解引用了，程序就会发生奔溃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cl* C = <span class="literal">nullptr</span>;</span><br><span class="line">    C-&gt;<span class="built_in">Print</span>();<span class="comment">//1.这里展开写就是“C-&gt;Print(C);”，这个函数被call的地址在编译的时候就被写入了，故正常调用（函数的地址并没有被存在对象里面，这里的解引用是“假象”）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，这个<code>this</code>指针补全了就是<code>类类型* const this</code>，这里的<code>const</code>只是避免了改变<code>this</code>的值，但是没有避免改变<code>*this</code>（也就是对象本身）的值，但是有的时候我们不希望<code>this</code>在编写代码的过程中不小心改变<code>this</code>指向对象的值，但是如果我们希望再加一个<code>const</code>（也就是成为<code>类类型* const this</code>）来避免<code>this</code>改变指向怎么办呢？这个<code>this</code>指针被编译器隐藏起来了呀！</p>
<p>因此我们可以直接在调用了<code>this</code>指针的函数签名的最后面加上<code>const</code>关键字，因此如果是上面的<code>void Print()</code>，在声明处可以改写成<code>void Print() const</code>，而在函数定义处也需要这么更改。</p>
<p>这种现象在本文的末尾我们还会再次提到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_year = year;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_month = month;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data::Print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;_year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;_month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;_day &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data d;</span><br><span class="line">    d.<span class="built_in">Init</span>(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    d.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-this指针的位置"><a href="#3-4-this指针的位置" class="headerlink" title="3.4.this指针的位置"></a>3.4.this指针的位置</h2><p>那么<code>this</code>指针应该存储到哪里去呢？存储到栈的区域，因为<code>this</code>本质还是一个形参，存储在栈上。但是这是不一定的，有的编译器会进行优化，比如：<code>VS2022</code>一般会采用寄存器<code>ecx</code>去优化代码，这点可以查看反汇编看看即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="number">00007F</span>F7B09420C0  mov         qword ptr [rsp+<span class="number">8</span>],rcx  </span><br><span class="line"><span class="number">00007F</span>F7B09420C5  push        rbp  </span><br><span class="line"><span class="number">00007F</span>F7B09420C6  push        rdi  </span><br><span class="line"><span class="number">00007F</span>F7B09420C7  sub         rsp,<span class="number">0E8</span>h  </span><br><span class="line"><span class="number">00007F</span>F7B09420CE  lea         rbp,[rsp+<span class="number">20</span>h]  </span><br><span class="line"><span class="number">00007F</span>F7B09420D3  lea         rcx,[__E91ADDBE_main@<span class="built_in">cpp</span> (<span class="number">07F</span>F7B09540E3h)]  </span><br><span class="line"><span class="number">00007F</span>F7B09420DA  call        __CheckForDebuggerJustMyCode (<span class="number">07F</span>F7B09413FCh)  </span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="number">00007F</span>F7B09420DF  mov         rax,qword ptr [<span class="keyword">this</span>]  </span><br><span class="line"><span class="number">00007F</span>F7B09420E6  mov         edx,dword ptr [rax]  </span><br><span class="line"><span class="number">00007F</span>F7B09420E8  mov         rcx,qword ptr [__imp_std::<span class="built_in">cout</span> (<span class="number">07F</span>F7B0952190h)]  </span><br><span class="line"><span class="number">00007F</span>F7B09420EF  call        qword ptr [__imp_std::basic_ostream&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt; &gt;::<span class="keyword">operator</span>&lt;&lt; (<span class="number">07F</span>F7B0952168h)]  </span><br><span class="line"><span class="number">00007F</span>F7B09420F5  lea         rdx,[std::endl&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt; &gt; (<span class="number">07F</span>F7B094103Ch)]  </span><br><span class="line"><span class="number">00007F</span>F7B09420FC  mov         rcx,rax  </span><br><span class="line"><span class="number">00007F</span>F7B09420FF  call        qword ptr [__imp_std::basic_ostream&lt;<span class="type">char</span>,std::char_traits&lt;<span class="type">char</span>&gt; &gt;::<span class="keyword">operator</span>&lt;&lt; (<span class="number">07F</span>F7B0952170h)]  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">00007F</span>F7B0942105  lea         rsp,[rbp+<span class="number">0</span>C8h]  </span><br><span class="line"><span class="number">00007F</span>F7B094210C  pop         rdi  </span><br><span class="line"><span class="number">00007F</span>F7B094210D  pop         rbp  </span><br><span class="line"><span class="number">00007F</span>F7B094210E  ret </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="number">00007F</span>F7B0942150  push        rbp  </span><br><span class="line"><span class="number">00007F</span>F7B0942152  push        rdi  </span><br><span class="line"><span class="number">00007F</span>F7B0942153  sub         rsp,<span class="number">108</span>h  </span><br><span class="line"><span class="number">00007F</span>F7B094215A  lea         rbp,[rsp+<span class="number">20</span>h]  </span><br><span class="line"><span class="number">00007F</span>F7B094215F  lea         rdi,[rsp+<span class="number">20</span>h]  </span><br><span class="line"><span class="number">00007F</span>F7B0942164  mov         ecx,<span class="number">0</span>Ah  </span><br><span class="line"><span class="number">00007F</span>F7B0942169  mov         eax,<span class="number">0</span>CCCCCCCCh  </span><br><span class="line"><span class="number">00007F</span>F7B094216E  rep stos    dword ptr [rdi]  </span><br><span class="line"><span class="number">00007F</span>F7B0942170  mov         rax,qword ptr [__security_cookie (<span class="number">07F</span>F7B094E018h)]  </span><br><span class="line"><span class="number">00007F</span>F7B0942177  <span class="keyword">xor</span>         rax,rbp  </span><br><span class="line"><span class="number">00007F</span>F7B094217A  mov         qword ptr [rbp+<span class="number">0</span>D8h],rax  </span><br><span class="line"><span class="number">00007F</span>F7B0942181  lea         rcx,[__E91ADDBE_main@<span class="built_in">cpp</span> (<span class="number">07F</span>F7B09540E3h)]  </span><br><span class="line"><span class="number">00007F</span>F7B0942188  call        __CheckForDebuggerJustMyCode (<span class="number">07F</span>F7B09413FCh)  </span><br><span class="line">        Cl C;</span><br><span class="line">        C.x = C.y = <span class="number">10</span>;</span><br><span class="line"><span class="number">00007F</span>F7B094218D  mov         dword ptr [rbp+<span class="number">0</span>Ch],<span class="number">0</span>Ah  </span><br><span class="line"><span class="number">00007F</span>F7B0942194  mov         eax,dword ptr [rbp+<span class="number">0</span>Ch]  </span><br><span class="line"><span class="number">00007F</span>F7B0942197  mov         dword ptr [C],eax  </span><br><span class="line">        C.<span class="built_in">Print</span>();</span><br><span class="line"><span class="number">00007F</span>F7B094219A  lea         rcx,[C]  </span><br><span class="line"><span class="number">00007F</span><span class="function">F7B094219E  call        <span class="title">Cl::Print</span> <span class="params">(<span class="number">07F</span>F7B0941474h)</span>  </span></span><br><span class="line"><span class="function">        <span class="keyword">return</span> 0</span>;</span><br><span class="line"><span class="number">00007F</span>F7B09421A3  <span class="keyword">xor</span>         eax,eax  </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00007F</span>F7B09421A5  mov         edi,eax  </span><br><span class="line"><span class="number">00007F</span>F7B09421A7  lea         rcx,[rbp<span class="number">-20</span>h]  </span><br><span class="line"><span class="number">00007F</span>F7B09421AB  lea         rdx,[string <span class="string">&quot;%d\n&quot;</span>+<span class="number">58</span>h (<span class="number">07F</span>F7B094AC80h)]  </span><br><span class="line"><span class="number">00007F</span>F7B09421B2  call        _RTC_CheckStackVars (<span class="number">07F</span>F7B0941384h)  </span><br><span class="line"><span class="number">00007F</span>F7B09421B7  mov         eax,edi  </span><br><span class="line"><span class="number">00007F</span>F7B09421B9  mov         rcx,qword ptr [rbp+<span class="number">0</span>D8h]  </span><br><span class="line"><span class="number">00007F</span>F7B09421C0  <span class="keyword">xor</span>         rcx,rbp  </span><br><span class="line"><span class="number">00007F</span>F7B09421C3  call        __security_check_cookie (<span class="number">07F</span>F7B0941208h)  </span><br><span class="line"><span class="number">00007F</span>F7B09421C8  lea         rsp,[rbp+<span class="number">0E8</span>h]  </span><br><span class="line"><span class="number">00007F</span>F7B09421CF  pop         rdi  </span><br><span class="line"><span class="number">00007F</span>F7B09421D0  pop         rbp  </span><br><span class="line"><span class="number">00007F</span>F7B09421D1  ret  </span><br></pre></td></tr></table></figure>

<h1 id="4-类的默认成员函数"><a href="#4-类的默认成员函数" class="headerlink" title="4.类的默认成员函数"></a>4.类的默认成员函数</h1><p>实际上，一个空类并不是真的“空”，编译器还会自动生成<code>6</code>个默认成员函数（默认成员函数是用户没有显式实现的。编译器会自动生成的成员函数称为默认&#x2F;缺省成员函数）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//某些成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>初始化和清理：构造函数完成初始化、析构函数完成清理</p>
</li>
<li><p>拷贝复制：拷贝构造函数使用同类对象初始化创建对象、赋值重载函数主要是把一个对象赋值给另外一个对象</p>
</li>
<li><p>取地址重载：主要是重载“普通对象”和“<code>const</code>对象”取地址，这两个很少会自己实现，目前还不太重要（有机会再细谈）</p>
</li>
</ol>
<h2 id="4-1-初始化和清理"><a href="#4-1-初始化和清理" class="headerlink" title="4.1.初始化和清理"></a>4.1.初始化和清理</h2><h3 id="4-1-1-构造函数"><a href="#4-1-1-构造函数" class="headerlink" title="4.1.1.构造函数"></a>4.1.1.构造函数</h3><p>构造函数是类里特殊的成员函数，虽然叫“构造”，但是它的工作不是开辟空间，而是在构造对象的时候自动被调用，进行对象的初始赋值工作（构造函数这个名字其实起得不够好，容易引发误会）。</p>
<p>构造函数可以帮助我们给与对象的成员变量初始赋值，而不至于因为忘记初始赋值变量而得到随机值或者崩溃的结果。</p>
<p>由于这个函数很特殊，所以在理解的时候可以特殊化理解，在调用的时候也要特殊使用。</p>
<blockquote>
<p>注意：这里说的是初始值赋值，而不是初始化！</p>
<p>原因是初始化只有一次，但是赋值可以多次，构造函数的作用类似于帮助我们在定义<code>int a</code>之后，编译器进行了<code>a=初始值</code>的功能。而不是实现了在定义<code>a</code>的同时初始化<code>a</code>，即<code>int a = 初始值</code>。这两种方式是完全不一样的，而这一点我们将在初始化列表的时候再次提及，这里学习构造函数的时候您只需要知道如何使用即可。</p>
</blockquote>
<p>构造函数的特征如下：</p>
<ol>
<li>函数名和类相同</li>
<li>没有返回值，也不用写<code>void</code>（这里的没有返回值不是返回空（<code>void</code>），而是根本就没有返回值这一说法，构造函数只需要做到初始化即可，因此我们说它是个特殊的函数）</li>
<li>对象实例化时编译器自动调用对应的构造函数，如果没有显示定义，编译器会生成默认的无参数构造函数，因此哪怕没写也会被调用</li>
<li>构造函数可以被重载</li>
</ol>
<p>接下来我们试着来写一下构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有构造函数的情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d1;<span class="comment">//创建一个d1结构体变量</span></span><br><span class="line">    d1.<span class="built_in">Init</span>(<span class="number">2022</span>, <span class="number">7</span>, <span class="number">5</span>);</span><br><span class="line">    d1.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">    Date d2;<span class="comment">//创建一个d2结构体变量</span></span><br><span class="line">    d2.<span class="built_in">Init</span>(<span class="number">2022</span>, <span class="number">7</span>, <span class="number">6</span>);</span><br><span class="line">    d2.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用构造函数的情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        _year = <span class="number">2023</span>;</span><br><span class="line">        _month = <span class="number">6</span>;</span><br><span class="line">        _day = <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d1;<span class="comment">//创建一个d1结构体变量</span></span><br><span class="line">    d1.<span class="built_in">Print</span>();<span class="comment">//自动调用构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此光是这个自动初始化，在<code>C++</code>中就能省略很多代码，还可以使用缺省值加强构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全缺省的构造函数（更加好用）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> year = <span class="number">2000</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2022</span>)</span></span>;</span><br><span class="line">    d1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2023</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">    d2.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="function">Date <span class="title">d3</span><span class="params">(<span class="number">2002</span>, <span class="number">9</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">    d3.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有显示定义构造函数，编译器就会自动生成一个无参的构造函数，如果有显示定义构造函数，编译器则不会自动生成。</p>
<p>但是如果编译器自动生成的构造函数，真的会帮助我们初始化吗？答案是：在默认生成的构造函数中：</p>
<ol>
<li><p>对内置类型成员（例如char、int、以及所有的指针类型等）不做初始化处理（可能有的编译器会做好处理，但是<code>C++</code>没有规定）</p>
</li>
<li><p>但是自定义类型成员（例如类类型）会回去调用自定义类型成员变量自己的默认构造函数（但是这种构造函数必须是全缺省或无参的，以及编译器默认生成的，有参数的构造函数是不算入默认构造函数的）。</p>
</li>
</ol>
<p>不对内置类型初始化可以说是<code>C++</code>早期设计的一个缺陷，当然有的新编译器对这些进行了处理，但是我们不能太依赖编译器的优化。</p>
<p>但是在<code>C++ 11</code>的时候打了一个补丁，可以通过给类内置类型成员变量设置缺省值来实现初始化，注意：是初始化，不是初始赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数对内置类型不起作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cl</span>(<span class="type">int</span> x = <span class="number">1</span>)<span class="comment">//C1类创建对象时使用的默认构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; _a1._x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _a2._x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cl _a1;</span><br><span class="line">    Cl _a2;</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d1;</span><br><span class="line">    d1.<span class="built_in">Print</span>();<span class="comment">//观察到内置的_a1、_a2自动进行了初始化，但是其他的三个内置类型没有初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数对内置类型不起作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cl</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cl</span>(<span class="type">int</span> x = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; _a1._x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _a2._x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Cl _a1;</span><br><span class="line">    Cl _a2;</span><br><span class="line">    <span class="type">int</span> _year = <span class="number">2000</span>;<span class="comment">//补丁</span></span><br><span class="line">    <span class="type">int</span> _month = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> _day = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Date d1;</span><br><span class="line">    d1.<span class="built_in">Print</span>();<span class="comment">//观察到都自动进行了初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这个补丁的缺省参数还有一个离谱的用法：可以在缺省处调用函数，例如使用<code>malloc()</code>。</p>
</blockquote>
<p>总结起来，实际上在<code>C++</code>中默认构造函数有三类：</p>
<ol>
<li><p>我们没写，编译器自动生成的默认构造函数</p>
</li>
<li><p>我们自己写的，全缺省的默认构造函数</p>
</li>
<li><p>我们自己写的，无参的默认构造函数</p>
</li>
</ol>
<p>另外，这三种默认构造函数不可能同时存在。</p>
<p>在<code>C++</code>中，构造函数是可以使用<code>private</code>访问权限进行修饰的。这种情况下，它们通常被用于实现特定的设计模式，如：“单例模式”或“工厂模式”等。</p>
<p>使用<code>private</code>构造函数可以防止类的实例化，也就是禁止用户直接创建对象。这样做的目的可能是为了控制对象的创建和确保只有特定的方式（即特点的参数）能够创建对象，避免用户错误创建具有危险性的对象。</p>
<blockquote>
<p>补充：以下是一个使用<code>private</code>构造函数实现单例模式的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="built_in">Singleton</span>() &#123;&#125;<span class="comment">//私有构造函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="type">static</span> Singleton instance;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//Singleton obj;//错误！无法直接创建对象</span></span><br><span class="line"> Singleton&amp; obj = Singleton::<span class="built_in">getInstance</span>();<span class="comment">//通过静态函数获取对象实例</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，私有构造函数<code>Singleton()</code>阻止了类实例的直接创建，而是通过静态成员函数<code>getInstance()</code>来获取唯一的类实例。</p>
</blockquote>
<blockquote>
<p>同时还要强调，<code>C++</code>不允许<code>类类型 对象名字()</code>这种写法，因为编译器没有办法确认这是定义一个对象，还是对一个函数进行声明。这样做是不会调用默认构造函数的，只需要把括号去掉就可以。</p>
</blockquote>
<h3 id="4-1-2-析构函数"><a href="#4-1-2-析构函数" class="headerlink" title="4.1.2.析构函数"></a>4.1.2.析构函数</h3><p>析构函数和构造函数功能相反。但是析构函数也不是完成对对象本身的销毁，局部对象销毁的工作由编译器完成。那析构函数究竟做什么呢？析构函数在对象销毁后会自动调用析构函数，完成对象中资源的清理工作（比如：对象内部的成员变量申请了堆空间的资源）。</p>
<p>析构函数的特征：</p>
<ol>
<li><p>析构函数的书写方法是在类名前面加上<code>~</code>，意思就是和构造函数功能相反</p>
</li>
<li><p>构造函数没有参数，也没有返回值</p>
</li>
<li><p>一个类只能有一个析构函数，若未显示定义，系统就会自动生成默认的析构函数。（即：析构函数不能重载）</p>
</li>
<li><p>对象生命周期结束时，<code>C++</code>编译系统自动调用析构函数</p>
</li>
<li><p>对象被析构的顺序符合栈先进后出的规律。先定义的后析构，后定义的先析构。如果是静态对象或者全局对象，则情况会再复杂一点。总体来看就是全局和静态的都要比局部的对象慢使用析构函数，而全局和静态的对象的析构顺序取决于两者的先后顺序</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        _y = y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.析构函数</span></span><br><span class="line">    ~<span class="built_in">Data1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Data1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//这个析构函数是没啥作用的，只是演示确实调用了析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.其他接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data1 C;</span><br><span class="line">    C.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C.<span class="built_in">Add</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, _x, _y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Data1::Add</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _x + _y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么析构函数在什么时候才更加具有作用呢？在调用堆空间的时候析构函数就有很大的作用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        _y = y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        _arr = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.析构函数</span></span><br><span class="line">    ~<span class="built_in">Data1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Data1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(_arr);</span><br><span class="line">        _arr = <span class="literal">nullptr</span>;</span><br><span class="line">        _x = _y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.其他接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ForPrint</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span>* _arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data1 C;</span><br><span class="line">    C.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, C.<span class="built_in">Add</span>());</span><br><span class="line">    C.<span class="built_in">ForPrint</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="comment">//这里就体现了析构函数的价值，使用析构函数就可以在这里避免内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, _x, _y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Data1::Add</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _x + _y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::ForPrint</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _arr[i] = i * i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, _arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果我们没有显式的写出析构函数，那么编译器自己执行的默认析构函数又有什么作用呢？和构造函数类似，隐式的析构函数：对内置类型不做处理，但是会处理自定义类型，调用字段自定义类型的默认析构函数，这里的默认析构函数包括编译器自己生成的析构函数、我们自己写的自定义析构函数。</p>
<p>其中编译器默认生成的析构函数的作用就是调用自定义类型的默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        _y = y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        _arr = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.析构函数</span></span><br><span class="line">    ~<span class="built_in">Data1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Data1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(_arr);</span><br><span class="line">        _arr = <span class="literal">nullptr</span>;</span><br><span class="line">        _x = _y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.其他接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ForPrint</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span>* _arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Data2</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        _d = cache;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Data1 _a;</span><br><span class="line">    Data1 _b;</span><br><span class="line">    <span class="type">int</span> _c = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* _d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data2 D;</span><br><span class="line">    cout &lt;&lt; D._a._arr;<span class="comment">//这个arr就会被默认的析构函数清理，因为_a的数据类型书自定义类型，拥有自己的析构函数，默认的析构函数去调用了这个自定义的析构函数</span></span><br><span class="line">    cout &lt;&lt; D._d;<span class="comment">//这里_d就不会被默认的析构函数释放掉，因为其是内置类型，因此造成了内存泄露</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="comment">//这里就体现了析构函数的价值，使用析构函数就可以在这里避免内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, _x, _y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Data1::Add</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _x + _y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::ForPrint</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _arr[i] = i * i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, _arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这和<code>Java</code>的垃圾回收机制是不一样的，不能混为一谈！利用析构函数在书写某些数据结构的时候就很方便。</p>
</blockquote>
<p>下面演示构造函数和析构函数的调用顺序问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A():&quot;</span> &lt;&lt; <span class="string">&quot;aa&quot;</span> &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A():&quot;</span> &lt;&lt; <span class="string">&quot;aa&quot;</span> &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">aa0</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> A <span class="title">aa1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">aa2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">A <span class="title">aa3</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> A <span class="title">aa4</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="comment">//构造aa0</span></span><br><span class="line">    <span class="comment">//构造aa1</span></span><br><span class="line">    <span class="comment">//构造aa2</span></span><br><span class="line">    <span class="comment">//构造aa3</span></span><br><span class="line">    <span class="comment">//构造aa4</span></span><br><span class="line">    <span class="comment">//析构aa3</span></span><br><span class="line">    <span class="comment">//析构aa2</span></span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">    <span class="comment">//构造aa2</span></span><br><span class="line">    <span class="comment">//构造aa3</span></span><br><span class="line">    <span class="comment">//析构aa3</span></span><br><span class="line">    <span class="comment">//析构aa2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//析构aa4</span></span><br><span class="line">    <span class="comment">//析构aa1</span></span><br><span class="line">    <span class="comment">//析构aa0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>等我们学到在<code>C++</code>中栈和队列的使用，就可以使用<code>C</code>语言和<code>C++</code>语言来解决这道力扣题目：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣：两个栈实现一个队列对比一下</a>，对比一下<code>C++</code>的便捷之处。</p>
</blockquote>
<h2 id="4-2-拷贝复制赋值"><a href="#4-2-拷贝复制赋值" class="headerlink" title="4.2.拷贝复制赋值"></a>4.2.拷贝复制赋值</h2><h3 id="4-2-1-拷贝构造函数（初始化的拷贝）"><a href="#4-2-1-拷贝构造函数（初始化的拷贝）" class="headerlink" title="4.2.1.拷贝构造函数（初始化的拷贝）"></a>4.2.1.拷贝构造函数（初始化的拷贝）</h3><p>在创建对象时，可否创建一个与已存在对象相同的的新对象呢？这个时候就可以用到拷贝构造函数，拷贝构造函数的特征有：</p>
<ol>
<li><p>只有单个形参，该形参是对本类型对象的“引用”（一般常用const修饰，使用传值方式编译器会直接报错，因为会引发无穷递归调用，当然用指针也不错，但是形式上怪怪的），在用已存在的类类型对象创建新对象时由编译器自动调用</p>
</li>
<li><p>拷贝构造函数实际上是构造函数的一个重载形式</p>
</li>
</ol>
<blockquote>
<p>补充：会引发无穷递归调用，是因为在传对象作为参数的时候，就发生了传值拷贝，也就是需要调用拷贝构造，而调用拷贝构造函数又需要传对象参数，传参数又需要调用拷贝构造…因此如果使用了<code>&amp;</code>引用就不会发生这样的事情，传递过来的参数就是参数本身，而不是参数的拷贝。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        _y = y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        _arr = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.析构函数</span></span><br><span class="line">    ~<span class="built_in">Data1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Data1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(_arr);</span><br><span class="line">        _arr = <span class="literal">nullptr</span>;</span><br><span class="line">        _x = _y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">const</span> Data1&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = d._x;</span><br><span class="line">        _y = d._y;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(cache, d._arr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span><span class="comment">//另外，拷贝构造函数还会涉及到深拷贝和浅拷贝的知识，不过这个后面再说了</span></span><br><span class="line">        _arr = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他接口</span></span><br><span class="line">    <span class="type">void</span> <span class="built_in">Print</span>(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> <span class="built_in">Add</span>(<span class="type">void</span>);</span><br><span class="line">    <span class="type">void</span> <span class="built_in">ForPrint</span>(<span class="type">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span>* _arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="built_in">test</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Data1 <span class="built_in">E</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    E.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, E.<span class="built_in">Add</span>());</span><br><span class="line">    <span class="comment">//方法一：兼容C的一种拷贝方法</span></span><br><span class="line">    Data1 F = E;</span><br><span class="line">    E.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="comment">//方法二：使用类的拷贝构造函数</span></span><br><span class="line">    Data1 <span class="built_in">G</span>(E);</span><br><span class="line">    G.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Data1::<span class="built_in">Print</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, _x, _y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> Data1::<span class="built_in">Add</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _x + _y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Data1::<span class="built_in">ForPrint</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _arr[i] = i * i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, _arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么构造拷贝函数如果是编译器默认生成的会有什么作用呢？实际上，编译器生成的默认拷贝构造函数会对“内置类型”直接按照字节的方式直接拷贝（是比较粗暴的浅拷贝），而“自定义类型”则回去调用其自己的拷贝构造函数完成拷贝。这里与构造函数和析构函数不太一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">int</span> x = <span class="number">1</span>, <span class="type">int</span> y = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = x;</span><br><span class="line">        _y = y;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Data()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        _arr = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.析构函数</span></span><br><span class="line">    ~<span class="built_in">Data1</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Data1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">free</span>(_arr);</span><br><span class="line">        _arr = <span class="literal">nullptr</span>;</span><br><span class="line">        _x = _y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Data1</span>(<span class="type">const</span> Data1&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">        _x = d._x;</span><br><span class="line">        _y = d._y;</span><br><span class="line">        <span class="type">int</span>* cache = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (!cache) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(cache, d._arr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">        _arr = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ForPrint</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">    <span class="type">int</span>* _arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _data1._x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _data1._y &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; _data3 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; _data4 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _data1._x = x;</span><br><span class="line">        _data1._y = y;</span><br><span class="line">        _data3 = <span class="number">100000</span>;</span><br><span class="line">        _data4 = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Data1 _data1;</span><br><span class="line">    Data1 _data2;</span><br><span class="line">    <span class="type">int</span> _data3 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> _data4 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Data2 H;</span><br><span class="line">    H.<span class="built_in">Print</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    H.<span class="built_in">Fun</span>(<span class="number">100000</span>, <span class="number">100000</span>);</span><br><span class="line">    H.<span class="built_in">Print</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="function">Data2 <span class="title">I</span><span class="params">(H)</span></span>;</span><br><span class="line">    <span class="comment">//这一步拷贝，使用的是编译器自动给出的默认拷贝构造函数。</span></span><br><span class="line">    <span class="comment">//对于内置类型会自己进行拷贝，没必要我们写出来</span></span><br><span class="line">    <span class="comment">//对于自定义类型则会回去调用自定义类型的拷贝函数</span></span><br><span class="line">    I.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, _x, _y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Data1::Add</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _x + _y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Data1::ForPrint</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _arr[i] = i * i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, _arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在函数传参的时候，尤其需要注意拷贝传值和引用传值中拷贝构造函数的动作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(int x = 0)&quot;</span> &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; aa)</span><br><span class="line">    &#123;</span><br><span class="line">        _a = aa._a;<span class="comment">//拷贝</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A(const A&amp; aa)-&gt;&quot;</span> &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~A()-&gt;&quot;</span> &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun0</span><span class="params">(A aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(A&amp; aa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">fun2</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A aa;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A&amp; <span class="title">fun3</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> A aa;</span><br><span class="line">    <span class="keyword">return</span> aa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A aa0;<span class="comment">//使用一次构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">aa1</span><span class="params">(aa0)</span></span>;<span class="comment">//使用一次拷贝构造</span></span><br><span class="line">    <span class="built_in">fun0</span>(aa0);<span class="comment">//由于使用的是拷贝传值方式，所以使用一次自定义的拷贝构造函数，使用完形参后，也要使用自定义析构函数</span></span><br><span class="line">    <span class="built_in">fun1</span>(aa0);<span class="comment">//由于使用的是引用传值方式，无需使用自定义的拷贝构造函数，也就无需使用自定义析构函数</span></span><br><span class="line">    <span class="built_in">fun2</span>();<span class="comment">//内部构建了一个static对象aa，使用了一次构造函数。并且其返回值需要拷贝给类型为A的匿名对象返回来，所以又使用了一次自定义拷贝构造函数，并且这个匿名对象还要使用一次析构函数</span></span><br><span class="line">    <span class="built_in">fun3</span>();<span class="comment">//内部再次构建一个static对象aa，使用了一次构造函数。由于使用的是引用返回，所以无需使用拷贝构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最后aa0使用析构函数，aa1也使用析构函数</span></span><br><span class="line">    <span class="comment">//最后把两个static对象aa分别使用析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，实际上不使用引用改为指针也是可以的，但是在语法书写形式上会很奇怪，感兴趣您可以自己试一试。</p>
<h3 id="4-2-2-赋值运算符重载函数（赋值拷贝）"><a href="#4-2-2-赋值运算符重载函数（赋值拷贝）" class="headerlink" title="4.2.2.赋值运算符重载函数（赋值拷贝）"></a>4.2.2.赋值运算符重载函数（赋值拷贝）</h3><p>要使用赋值重载函数，还需要先深入了解运算符重载函数（<code>Java</code>没有运算符重载）。</p>
<p>运算符重载的应用很多，比如：对象和对象直接要进行运算符运算。为什么需要重载呢？因为编译器只会内置类型的运算符运算，无法通过运算符运算自定义的类对象，这个时候就需要运算符重载了，例如下面的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有运算符重载</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> x = <span class="number">2000</span>, <span class="type">int</span> y = <span class="number">1</span>, <span class="type">int</span> z = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = x;</span><br><span class="line">        _month = y;</span><br><span class="line">        _day = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time A;</span><br><span class="line">    A.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="function">Time <span class="title">B</span><span class="params">(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    Time C = B - A;<span class="comment">//这里的编译器就无法知道究竟如何运算</span></span><br><span class="line">    C.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面对这种情况，我们就可以使用关键字<code>operator</code>，这个关键字的使用格式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 <span class="keyword">operator</span>操作符(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，不能通过连接其他符号来创建新的操作符，比如<code>operator@</code>。下面我们来演示一个运算符重载的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">      <span class="comment">//1.构造函数 </span></span><br><span class="line">      <span class="built_in">Time</span>(<span class="type">int</span> x = <span class="number">2000</span>, <span class="type">int</span> y = <span class="number">1</span>, <span class="type">int</span> z = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          _year = x; </span><br><span class="line">          _month = y; </span><br><span class="line">          _day = z; </span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//注意这里是公有限定符</span></span><br><span class="line">      <span class="type">int</span> _year; </span><br><span class="line">      <span class="type">int</span> _month; </span><br><span class="line">      <span class="type">int</span> _day; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2.全局运算符重载</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>-(Time x, Time y) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">return</span> x._year - y._year; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      Time A;</span><br><span class="line">      A.<span class="built_in">Print</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="function">Time <span class="title">B</span><span class="params">(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">      B.<span class="built_in">Print</span>();</span><br><span class="line">      </span><br><span class="line">      Time C = (B - A); </span><br><span class="line">      C.<span class="built_in">Print</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外运算符重载中的重载操作符必须有一个类类型参数（例如两个操作符都是<code>int</code>，这是不被允许的）。</p>
<p>还有五个运算符不允许重载的：<code>.*</code>、<code>::</code>、<code>sizeof</code>、<code>?:</code>、<code>.</code></p>
<p>运算符重载有两种写法，一种是全局运算符重载（在类外声明和定义），这种就需要把操作符需要的所有操作数写成参数列表写清楚（因为没有<code>this</code>指针）。</p>
<p>但是如果像上面这么写的话，万一类里的成员变量并不是公有的而是私有的怎么办呢？全局运算符重载是没有办法直接访问类的私有成员的（除非使用友元），因此<code>C++</code>还提供了第二种写法：直接写在类里成为类的成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数</span></span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> x = <span class="number">2000</span>, <span class="type">int</span> y = <span class="number">1</span>, <span class="type">int</span> z = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = x;</span><br><span class="line">        _month = y;</span><br><span class="line">        _day = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.运算符重载函数</span></span><br><span class="line">    <span class="type">int</span> <span class="keyword">operator</span>-(Time x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _year - x._year;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time A;</span><br><span class="line">    A.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="function">Time <span class="title">B</span><span class="params">(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    B.<span class="built_in">Print</span>();</span><br><span class="line">    Time C = (B - A);</span><br><span class="line">    C.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么只传递一个参数也能通过呢？不要忘记<code>this</code>指针的存在，上述的代码还可以显式写成下面这个样子（即编译器处理后的样子，自己直接这么写是会报错的）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">using namespace std;</span></span><br><span class="line"><span class="comment">class Time</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    //1.构造函数</span></span><br><span class="line"><span class="comment">    Time(int x = 2000, int y = 1, int z = 1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        _year = x;</span></span><br><span class="line"><span class="comment">        _month = y;</span></span><br><span class="line"><span class="comment">        _day = z;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    void Print()</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; _year &lt;&lt; &quot;-&quot; &lt;&lt; _month &lt;&lt; &quot;-&quot; &lt;&lt; _day &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //2.运算符重载函数</span></span><br><span class="line"><span class="comment">    int operator-(Time* const this, Time x)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return this-&gt;_year - x._year;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">private:</span></span><br><span class="line"><span class="comment">    int _year;</span></span><br><span class="line"><span class="comment">    int _month;</span></span><br><span class="line"><span class="comment">    int _day;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">int main()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    Time A;</span></span><br><span class="line"><span class="comment">    A.Print();</span></span><br><span class="line"><span class="comment">    Time B(2023, 1, 1);</span></span><br><span class="line"><span class="comment">    B.Print();</span></span><br><span class="line"><span class="comment">    Time C = (&amp;B - A);</span></span><br><span class="line"><span class="comment">    C.Print();</span></span><br><span class="line"><span class="comment">    return 0;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以利用运算符重载函数来写一个日期加法，<code>日期(data)+天数(int)=日期(data)</code>，感兴趣的话您可以自己先实现一下，或者直接看下一章节的《日期类的实现》。</p>
<p>接下来我们来看看赋值运算符重载的使用。<br>这里我们提前展示后面日期类里的赋值运算符重载的写法（之后会详细介绍日期类的实现）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.构造函数（内联的构造函数）</span></span><br><span class="line">    <span class="built_in">Data</span>(<span class="type">int</span> year = <span class="number">1900</span>, <span class="type">int</span> month = <span class="number">1</span>, <span class="type">int</span> day = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.拷贝构造函数（使用默认的即可）</span></span><br><span class="line">    <span class="comment">//3.赋值运算符重载函数</span></span><br><span class="line">    <span class="comment">//3.1.写法1（可以是可以，但是不支持连续赋值）</span></span><br><span class="line">    <span class="comment">//void operator=(const Data&amp; d)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    //this指向的是“=”前面的操作数，d是“=”后面的操作是</span></span><br><span class="line">    <span class="comment">//    _year = d._year;</span></span><br><span class="line">    <span class="comment">//    _month = d._month;</span></span><br><span class="line">    <span class="comment">//    _day = d._day;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//3.2.写法2（允许连续赋值）</span></span><br><span class="line">    Data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Data&amp; d)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this指向的是“=”前面的操作数，d是“=”后面的操作是</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)<span class="comment">//用地址值判断比较好</span></span><br><span class="line">        &#123;</span><br><span class="line">            _year = d._year;</span><br><span class="line">            _month = d._month;</span><br><span class="line">            _day = d._day;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _year &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _month &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; _day &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _year;</span><br><span class="line">    <span class="type">int</span> _month;</span><br><span class="line">    <span class="type">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Data <span class="title">d1</span><span class="params">(<span class="number">2022</span>, <span class="number">7</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line">    d1.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="function">Data <span class="title">d2</span><span class="params">(d1)</span></span>;</span><br><span class="line">    d2.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="function">Data <span class="title">d3</span><span class="params">(<span class="number">2022</span>, <span class="number">8</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line">    <span class="function">Data <span class="title">d4</span><span class="params">(<span class="number">2023</span>, <span class="number">6</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">    d4 = d1 = d3;<span class="comment">//这里就需要用到赋值运算符重载函数，而不是拷贝构造函数，并且注意这里是连续赋值</span></span><br><span class="line">    d3.<span class="built_in">Print</span>();</span><br><span class="line">    d1.<span class="built_in">Print</span>();</span><br><span class="line">    d4.<span class="built_in">Print</span>();</span><br><span class="line">    d2 = d2;<span class="comment">//这里使用的是自己给自己赋值，赋值运算符重载可以考虑在这里优化</span></span><br><span class="line">    d2.<span class="built_in">Print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，赋值运算符函数不同于其他的运算符重载函数，赋值运算符重载只能重载为类的成员函数，不能直接重载成全局函数。如果您这么做了，将会直接报错（<code>error C2801: operator= 必须是成员函数</code>）</p>
<p>这样错误的原因本质是：</p>
<ol>
<li><p>如果您不写赋值运算符重载成员函数，编译器会生成一个默认的赋值运算符重载成员函数</p>
</li>
<li><p>如果是内置类型成员变量：直接按字节赋值的（因此上面的代码例子实际上是不需要自己写一个赋值运算符重载函数的，编译器自动会把三个<code>int</code>类型的成员进行按字节赋值，上面只是演示如何使用赋值重载成员函数而已）</p>
</li>
<li><p>如果是自定义类型成员变量：需要调用对应类的赋值运算符重载成员函数完成赋值（这里很像拷贝构造函数的使用）</p>
</li>
<li><p>这个时候问题来了，如果写了全局的赋值运算符重载函数，那么将和这个默认生成的赋值运算符重载函数发冲突，对象不知道该调用哪一个函数（注意，我们之前是因为在类里面写了成员函数，编译器才不会重复生成默认构造函数的，这里我们把赋值重载函数写成了全局，编译器就还是会生成一个默认的赋值重载成员函数，这两个函数就同时存在了）。</p>
</li>
</ol>
<h2 id="4-3-取地址重载函数"><a href="#4-3-取地址重载函数" class="headerlink" title="4.3.取地址重载函数"></a>4.3.取地址重载函数</h2><h3 id="4-3-1-const成员函数"><a href="#4-3-1-const成员函数" class="headerlink" title="4.3.1.const成员函数"></a>4.3.1.const成员函数</h3><p><code>C++</code>的类型检查很严格，对于<code>const</code>对象，不可以直接使用没有<code>const</code>修饰<code>this</code>指针的成员函数。但是<code>this</code>是编译器自动给我们加上的，我们在哪里写<code>const</code>呢？答案是直接写在成员函数的函数头右侧（这种现象我们之前提到过）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有const成员函数的情况下</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(a = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          _a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span><span class="comment">//这里的this展开写是A* const this</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> A <span class="title">aa2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    aa1.<span class="built_in">Print</span>();<span class="comment">//这里传递&amp;aa1（类型是A*）,权限放小，没有关系</span></span><br><span class="line">    aa2.<span class="built_in">Print</span>();<span class="comment">//这里就会有问题</span></span><br><span class="line">    <span class="comment">//因为this指针的存在，使得这里调用Print的时候是&amp;aa2（类型为const A*），权限放大了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此就需要让编译器给<code>this</code>前面加上<code>const</code>，修改为下面这个代码就可以通过编译了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写了const成员函数的情况</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(a = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          _a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span><span class="comment">//这里的this展开写就是const A* const this</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; _a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">aa1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">const</span> A <span class="title">aa2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    aa1.<span class="built_in">Print</span>();</span><br><span class="line">    aa2.<span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>const</code>加到普通的函数返回值是没有什么意义的，因为正常情况下，函数的返回值具有常属性，没有必要再多此一举加上<code>const</code>。</p>
</blockquote>
<p>思考一下下面的几个问题：</p>
<ol>
<li><p><code>const</code>对象可以调用非<code>const</code>成员函数吗？（不可以）</p>
</li>
<li><p>非<code>const</code>对象可以调用<code>const</code>成员函数吗？（可以，发生隐式转化）</p>
</li>
<li><p><code>const</code>成员函数内可以调用其他非<code>const</code>成员函数吗？（不可以，本质是<code>const</code>的<code>this</code>调用了非<code>const</code>的成员函数，这符合上面的第<code>1</code>条。但是可以调用<code>const</code>成员变量，不过这会造成一个现象：声明了一个<code>const</code>成员函数，就很有可能需要声明一系列的<code>const</code>函数）</p>
</li>
<li><p>非<code>const</code>成员函数可内以调用其他<code>const</code>成员函数吗？（可以，本质是非<code>const</code>的<code>this</code>调用了<code>const</code>的成员函数，这符合上面的第<code>2</code>条）</p>
</li>
</ol>
<p>给某些只读的成员函数加上<code>const</code>修饰<code>this</code>最重要的好处是：<code>const</code>对象可以正常调用成员函数，不用担心在编码的时候被人为破坏。</p>
<blockquote>
<p>注意：声明和定义在加<code>const</code>上要同步加上。</p>
</blockquote>
<h3 id="4-3-2-取地址操作符重载"><a href="#4-3-2-取地址操作符重载" class="headerlink" title="4.3.2.取地址操作符重载"></a>4.3.2.取地址操作符重载</h3><p>取地址在默认情况下是很够用的，所以一般是不需要将<code>&amp;</code>重载的，除非有的时候不希望被别人取到有地址（但是这种应用极少，不过也不是没有）。</p>
<p>对于自定义类型，理论上是不能直接使用<code>&amp;</code>的，但是我们在编译器中是能通过编译并且运行的。这是因为类还有一个默认成员函数：取地址重载成员函数。我们可以显示写出下面得成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Data* <span class="keyword">operator</span>&amp;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">const</span> Data* <span class="keyword">operator</span>&amp;()<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>可以返回一个虚假的地址…</p>
<h1 id="5-日期类的实现"><a href="#5-日期类的实现" class="headerlink" title="5.日期类的实现"></a>5.日期类的实现</h1><p>这里我实现了一个<a href="./%E9%A2%9D%E5%A4%96%E8%A1%A5%E5%85%85%EF%BC%9AC++%E6%97%A5%E6%9C%9F%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0.md">简单的日期类</a>，您可以去看看。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/01/2-C-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="limou3434">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/01/2-C-%E5%9F%BA%E7%A1%80%E8%BF%90%E7%94%A8/" itemprop="url">2.C++基础运用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-01T18:08:22+08:00">
                2023-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-C-关键字"><a href="#1-C-关键字" class="headerlink" title="1.C++关键字"></a>1.C++关键字</h1><p><code>C++</code>比<code>C</code>语言多了很多关键字，如下表格：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>asm</td>
<td>do</td>
<td>if</td>
<td>return</td>
<td>try</td>
<td>continue</td>
</tr>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typedef</td>
<td>for</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typeid</td>
<td>public</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>typename</td>
<td>throw</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>union</td>
<td>wchar_t</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>unsigned</td>
<td>default</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>using</td>
<td>friend</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>virtual</td>
<td>register</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>void</td>
<td>true</td>
</tr>
<tr>
<td>const_cast</td>
<td>float</td>
<td>protected</td>
<td>this</td>
<td>volatile</td>
<td>while</td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="2-命名空间"><a href="#2-命名空间" class="headerlink" title="2.命名空间"></a>2.命名空间</h1><h2 id="2-1-命名空间概念"><a href="#2-1-命名空间概念" class="headerlink" title="2.1.命名空间概念"></a>2.1.命名空间概念</h2><p>在<code>C++</code>中，变量、函数、类是大量存在的，这些名字都会存储在全局作用域中，因此在使用的时候可能导致很多的冲突。</p>
<p>这种情况在多人协作的情况下尤其突出，多人份提交的代码很容易出现命名冲突的问题。</p>
<p>因此出现了针对命名重复的方案：命名空间。</p>
<ol>
<li><p>使用命名空间可以对标识符的名字进行本地化，避免造成命名冲突或名字污染，<code>namespace</code>就是针对这个问题的的关键字，而<code>C</code>语言没有办法解决这个问题（例如将库函数名字作为新定义的变量，但是这在<code>C++</code>中可以）</p>
</li>
<li><p><code>C++</code>允许同一个工程存在多个同名称的命名空间，编译器最后会合并成同一个命名空间里</p>
</li>
<li><p><code>C++</code>为了防止名字的冲突，便把标准库的东西都放入<code>std</code>这个命名空间。这样就可以使用标准库的名字来命名标准库的变量和函数。因此，要使用标准库的变量和函数也需要写出它的命名空间</p>
</li>
<li><p>由于<code>C++</code>采用命名空间，这个时候就需要注意新的坑了，在包含某些头文件的时候，有可能和自己定义的变量冲突，这个时候就需要使用好<code>namespace</code>关键字</p>
</li>
<li><p>命名空间可以嵌套使用</p>
</li>
</ol>
<h2 id="2-2-创建命名空间"><a href="#2-2-创建命名空间" class="headerlink" title="2.2.创建命名空间"></a>2.2.创建命名空间</h2><p>我们可以使用关键字<code>namespace</code>创建命名空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面是这块命名空间的名字，前者namespace是命名空间的关键字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> n)</span><span class="comment">//在命名空间内定义一个函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Limou</span><span class="comment">//在命名空间内定义一个结构体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="type">char</span> b;</span><br><span class="line">        <span class="type">float</span> c;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">namespace</span> limou<span class="comment">//在命名空间内嵌套一个命名空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-命名空间合并"><a href="#2-3-命名空间合并" class="headerlink" title="2.3.命名空间合并"></a>2.3.命名空间合并</h2><p>C++对于同名的命名空间不会认为是冲突，而是认为是同一个命名空间，会自动进行合并。</p>
<h2 id="2-4-命名空间授权"><a href="#2-4-命名空间授权" class="headerlink" title="2.4.命名空间授权"></a>2.4.命名空间授权</h2><p>有的人喜欢叫使用命名空间为“展开命名空间”，但是个人认为说成“授权”的方式可能会更好理解，即：命名空间通过<code>using</code>授权给我们使用它的内部成员名字的权限。</p>
<h3 id="2-4-1-小范围使用"><a href="#2-4-1-小范围使用" class="headerlink" title="2.4.1.小范围使用"></a>2.4.1.小范围使用</h3><p>使用作用域限定符<code>::</code>单独引用，这样可以从命名空间中，单独拎出某个名字来使用，虽然可能有些繁琐，但是是最能解决命名冲突的方案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命名空间名::名字;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命名空间名称::命名空间内的成员名字;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面的&quot;limou3434&quot;是这块命名空间的名字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">function</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//在命名空间内定义一个函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> val; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Limou</span><span class="comment">//在命名空间内定义一个结构体</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> limou<span class="comment">//在命名空间内嵌套一个命名空间</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> e = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> g = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1.使用变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, limou3434::print);</span><br><span class="line">    <span class="comment">//2.使用函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, limou3434::<span class="built_in">function</span>(<span class="number">9</span>));</span><br><span class="line">    <span class="comment">//3.使用结构体</span></span><br><span class="line">    limou3434::Limou A;</span><br><span class="line">    A.a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, A.a);</span><br><span class="line">    <span class="comment">//4.使用命名空间内嵌套的命名空间内的变量 </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, limou3434::limou::e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-中范围使用"><a href="#2-4-2-中范围使用" class="headerlink" title="2.4.2.中范围使用"></a>2.4.2.中范围使用</h3><p>使用关键字<code>using</code>将命名空间的某个成员引入（项目里经常使用）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 命名空间名::名字;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//using其实就是英语单词“use”的变形</span></span><br><span class="line"><span class="comment">//using 命名空间名称::命名空间内成员名字;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面是这块命名空间的名字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> limou3434::print;<span class="comment">//单独拎出一个变量，之后可以一直使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, print);</span><br><span class="line">    print += <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, print);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, val);//这个语句不可以使用，因为没有单独拎出val名字</span></span><br><span class="line">    <span class="keyword">using</span> limou3434::val;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, val);<span class="comment">//这里就可以使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-大范围使用"><a href="#2-4-3-大范围使用" class="headerlink" title="2.4.3.大范围使用"></a>2.4.3.大范围使用</h3><p>使用关键字<code>using</code>和<code>namespace</code>将命名空间的整体引入。这样写可能不太好，会把所有标准库的名字全部暴露，有可能和自己写的名字冲突。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> 命名空间名;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> limou3434<span class="comment">//后面是这块命名空间的名字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> print = <span class="number">100</span>;<span class="comment">//在命名空间内定义一个变量</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> limou3434;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//这里使用了标准命名空间，内部有标准库的各种变量、函数等名字，这里是为了使用cout这个名字，cout的功能是输出，类似printf()，但是比printf()更加智能，可以自动识别变量的类型进行输出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; print;</span><br><span class="line">    cout &lt;&lt; val;</span><br><span class="line">    cout &lt;&lt; x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充：</p>
<p>一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于命名空间中，只有使用<code>using</code>才可以在命名空间外被使用。</p>
</blockquote>
<h1 id="3-C-输入和输出"><a href="#3-C-输入和输出" class="headerlink" title="3.C++输入和输出"></a>3.C++输入和输出</h1><p>在<code>2.4.3.大范围</code>中我们使用了<code>std</code>，接下来让我们来详细了解一下<code>C++</code>特有的输入输出方式。</p>
<h2 id="3-1-输入输出的使用"><a href="#3-1-输入输出的使用" class="headerlink" title="3.1.输入输出的使用"></a>3.1.输入输出的使用</h2><p><code>C++</code>使用了更加灵活方便的<code>cin</code>和<code>cout</code>进行流输入和流输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span><span class="comment">//必须包含这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="comment">//并且释放和cin和cout相关的命名空间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//endl是换行的意思，类似&#x27;\n&#x27;，实际上您也可以使用&#x27;\n&#x27;替代endl得到换行的效果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-输入输出的解释"><a href="#3-2-输入输出的解释" class="headerlink" title="3.2.输入输出的解释"></a>3.2.输入输出的解释</h2><ol>
<li><p>使用<code>cout</code>和<code>cin</code>必须包含头文件<code>&lt;iostream&gt;</code>（注意新的<code>C++</code>标准头文件不再使用<code>.h</code>来表示一个头文件。早期标准库将所有功能都在全局域中实现，声明在<code>.h</code>的头文件中，使用的时候<code>include</code>一下就行，后来将这些实现改到<code>std</code>命名空间下。为了和头文件区分并且正确使用命名空间，规定<code>C++</code>头文件不带<code>.h</code>），两者的前缀<code>c</code>就是单词<code>console</code>即“控制台”的缩写。另外，有的老旧编译器还支持<code>#include&lt;isstream.h&gt;</code>的形式，而后续的编译器大部分都不再支持</p>
</li>
<li><p>使用<code>cout</code>和<code>cin</code>必须指出其命名空间<code>std</code>，就是标准命名空间</p>
</li>
<li><p><code>&lt;&lt;</code>是流插入运算符，<code>&gt;&gt;</code>是流提取运算符（也有叫“输入输出符号”的，统称“流运算符”）</p>
</li>
<li><p><code>C++</code>的输入输出可以自动识别变量的类型，无需指定输入输出格式，这里的底层逻辑等您学到“运算符重载”后就可以明白了</p>
</li>
<li><p>虽然是自动控制，但是<code>cout</code>和<code>cin</code>还有其他复杂用法，包括控制输出格式等等，但是这些对比后续学习内容不算重点，就先不在此描述（而且<code>C++</code>也依旧支持<code>C</code>的<code>printf()</code>和<code>scanf()</code>等库函数）</p>
</li>
<li><p><code>std</code>是<code>C++</code>标准库的命名空间，在日常练习中虽然可以直接将整个命名空间全部暴露，但是在大型工程中，一般都会使用作用域限定符，只暴露某一成员</p>
</li>
<li><p><code>endl</code>是“换行”的意思。也是需要包含头文件<code>&lt;iostream&gt;</code>，可以用转义字符<code>\n</code>替代</p>
</li>
</ol>
<blockquote>
<p>补充：</p>
<ol>
<li><p>实际上<code>cin</code>是<code>istream</code>类的对象，而<code>cout</code>是<code>ostream</code>类的对象.</p>
</li>
<li><p>流运算符<code>&lt;&lt;</code>和<code>&gt;&gt;</code>则是经过运算符重载后的运算符</p>
</li>
</ol>
<p>上面这部分内容等到后面学到“类”的时候再回来看看您就能明白了…</p>
<p>现在对您来说只需要知道这么使用即可！</p>
</blockquote>
<h1 id="4-缺省参数"><a href="#4-缺省参数" class="headerlink" title="4.缺省参数"></a>4.缺省参数</h1><h2 id="4-1-缺省函数的概念"><a href="#4-1-缺省函数的概念" class="headerlink" title="4.1.缺省函数的概念"></a>4.1.缺省函数的概念</h2><p>在<code>C++</code>中声明或定义函数的时候可以为函数指定一个缺省值（默认值，这里是翻译问题，才叫“缺省”）。如果在使用函数的时候没有指定实参，就使用默认值为函数参数，否者使用指定的实参。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span><span class="comment">//这里的a就有一个缺省参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你好！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-全半缺省的使用"><a href="#4-2-全半缺省的使用" class="headerlink" title="4.2.全半缺省的使用"></a>4.2.全半缺省的使用</h2><ol>
<li><p>全缺省：可以只指定一部分参数有默认值，或者全部指定有默认值</p>
</li>
<li><p>半缺省：半缺省函数的参数必须“从右往左”给出，不可间隔给予默认值，因此<code>C++</code>没有允许<code>(,,1)</code>这样的写法</p>
</li>
<li><p>缺省值不能在函数声明和定义里同时出现，要以声明为准（只写在声明中，当然如果函数声明和定义是同一份代码就没有这个问题）</p>
</li>
<li><p>缺省值必须是常量或者全局变量</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h文件</span></span><br><span class="line"><span class="function">voide <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">100</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.cpp文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">50</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="comment">//某些具体代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在VS2022中哪怕重定义的缺省的值是一样的也不行</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();<span class="comment">//报错无法使用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-函数重载"><a href="#5-函数重载" class="headerlink" title="5.函数重载"></a>5.函数重载</h1><h2 id="5-1-重载的概念"><a href="#5-1-重载的概念" class="headerlink" title="5.1.重载的概念"></a>5.1.重载的概念</h2><p>在现实生活中有的词语可以根据上下文语义，从而产生不同的意思，这实际上就是一种重载的体现。</p>
<ol>
<li><p>在<code>C++</code>中允许在同一个“作用域”中声明几个类似功能的同名函数。这些函数的形参列表（形参个数、形参类型、形参顺序）是不同的，常常用来处理实现功能类似、数据不同的问题。而且也根据这个形参的使用来区分不同重载的函数（注意不同命名空间内定义同一个名字的函数虽然可以，但是那个不叫“重载”）</p>
</li>
<li><p>需要注意的是：“返回值的不同、形参名字的不同”都不构成函数重载</p>
</li>
<li><p>实际上<code>cout</code>、<code>cin</code>能够自动识别的本质也是函数重载，在库里面已经帮我们实现好了</p>
</li>
</ol>
<blockquote>
<p>注意：返回值不计入重载</p>
<p>这一点很重要，返回的类型并不能构成重载，理由如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>; </span><br></pre></td></tr></table></figure>

<p>如果这里两个<code>add()</code>构成了重载，那么在函数调用的时候（比如：<code>add(1, 2)</code>）就会发生混乱，编译器不知道要调用哪一个函数，是返回<code>int</code>还是<code>double</code>。</p>
</blockquote>
<h2 id="5-2-重载的使用"><a href="#5-2-重载的使用" class="headerlink" title="5.2.重载的使用"></a>5.2.重载的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;你好！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">function</span><span class="params">(<span class="type">char</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>();</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">function</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-重载的原理"><a href="#5-3-重载的原理" class="headerlink" title="5.3.重载的原理"></a>5.3.重载的原理</h2><p>为什么重载在<code>C</code>语言不支持，而<code>C++</code>语言却支持？（以下现象只有在汇编代码中才能看出来）</p>
<ol>
<li><p>要明白这个过程首先需要重新复习<code>C++</code>代码的编译链接过程：<br> a.预处理：头文件展开、宏替换、条件编译、去掉注释<br> b.编译：语法检查、生成汇编代码<br> c.汇编：将汇编代码转化为二进制机器码，生成目标文件<br> d.链接：将程序合起来，生成可执行程序（这个合起来的意思就是将只给声明的函数地址找到链接起来，如果找不到就是链接错误。而具体的找法就是为每个目标文件做一个符号表，通过符号表来寻找对应的地址）</p>
</li>
<li><p>而在<code>C</code>语言就是在这个链接阶段，查找符号表的时候，有两个同名函数符号且地址不同，这就发生了冲突。即：“<code>C</code>语言直接将函数名作为符号来对应函数地址”</p>
</li>
<li><p>而<code>C++</code>语言在这个链接阶段时，函数符号是根据函数名和参数名来生成的，这样符号名字不一样，地址也不一样，就可以构成函数重载的用法。即：<code>C++</code>语言将函数名和参数类型信息等组合起来构成符号来对应函数地址，这也解释了为什么函数重载需要靠参数类型来标识不同的重载函数</p>
</li>
</ol>
<p>综上所述，<code>C</code>语言不支持函数重载（没有函数修饰规则），<code>C++</code>语言支持函数重载（有函数修饰规则）。</p>
<p>另外，在<code>C++</code>这个符号表里的“函数修饰规则”在不同环境是有可能不一样的，但是一定是依赖函数参数来生成的</p>
<p>这种原理就是“名字修饰”，另外这里有一份<code>VS</code>的“<a target="_blank" rel="noopener" href="https://blog.csdn.net/lioncolumn/article/details/10376891">C&#x2F;C++调用约定博文</a>”</p>
<blockquote>
<p>补充：重载和缺省值的结合</p>
<p>如果给出下面代码会发生什么情况呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;void func(int a,int b)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//调用成功</span></span><br><span class="line"> <span class="built_in">func</span>(<span class="number">1</span>);<span class="comment">//调用失败，重载语义模糊，编译器不知道该调用哪一个函数</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6.引用"></a>6.引用</h1><h2 id="6-1-引用的概念"><a href="#6-1-引用的概念" class="headerlink" title="6.1.引用的概念"></a>6.1.引用的概念</h2><p>引用不是新定义一个变量，而是为已存变量取个别名，引用变量不会开辟新的内存空间，它和它引用的变量共用同一块内存空间。</p>
<h2 id="6-2-引用的使用"><a href="#6-2-引用的使用" class="headerlink" title="6.2.引用的使用"></a>6.2.引用的使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型&amp; 引用变量名(对象名) = 引用实体;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>引用必须在定义的时候就必须进行初始化，<code>C++</code>的引用一旦初始化就不能改变指向，这也是<code>C++</code>不能完全脱离指针的一个体现（<code>Java</code>是可以改变指向的）</p>
</li>
<li><p>一个变量&#x2F;对象可以有多个引用</p>
</li>
<li><p>引用一旦引用一个实体，就再也不能引用其他实体</p>
</li>
<li><p>“引用”是给变量取别名，<code>typedef</code>是给类型取别名，两者有某些相似的地方</p>
</li>
<li><p>还可以给引用后的别名取引用，也就是嵌套引用</p>
</li>
<li><p>引用更多是在函数的参数处使用，尤其是大对象传参的时候会提高效率</p>
</li>
<li><p>引用还可以在函数的返回值处使用，但是注意函数内部定义的变量一旦出函数作用域就会被销毁，此时不能使用引用返回，只能使用传值返回（但是如果这个局部变量被静态关键字<code>static</code>修饰，那就可以直接使用引用返回）</p>
</li>
<li><p>引用的变量类型和引用类型不一样时，会发生权限放大错误，本质是创建了临时变量，而临时变量具有常属性</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用的基本使用</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">b = x;<span class="comment">//因此这个语句的意思是“x的值赋给b”，而不是“x成为了b的别名”，这跟指针就有很大的区别</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int&amp; ra = a; //该语句编译时会出错，a为常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ra = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; b = 10; //该语句编译时会出错，b为常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="comment">//int&amp; rd = d; //该语句编译时会出错，由于类型不同所以d会先赋值给一个临时变量，该临时变量的类型是const int，但是使用引用的时候类型不匹配（int和const int不匹配），发生了权限放大</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rd = d;<span class="comment">//此时就可以正常引用了</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-1-多重引用"><a href="#6-2-1-多重引用" class="headerlink" title="6.2.1.多重引用"></a>6.2.1.多重引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用后变量的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;<span class="comment">//实际变量</span></span><br><span class="line">    <span class="type">int</span>&amp; a1 = a;<span class="comment">//引用1</span></span><br><span class="line">    <span class="type">int</span>&amp; a2 = a;<span class="comment">//引用2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, a, a1, a2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p %p %p\n&quot;</span>, &amp;a, &amp;a1, &amp;a2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-做函数参数"><a href="#6-2-2-做函数参数" class="headerlink" title="6.2.2.做函数参数"></a>6.2.2.做函数参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数参数列表的引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="type">int</span> tmp = a;</span><br><span class="line">      a = b;</span><br><span class="line">      b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-3-做函数返回值"><a href="#6-2-3-做函数返回值" class="headerlink" title="6.2.3.做函数返回值"></a>6.2.3.做函数返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数返回值的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">function</span><span class="params">(<span class="type">int</span>&amp; x)</span><span class="comment">//int&amp; x = i，因此x是i的别名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x++;<span class="comment">//这个x++等价于i++</span></span><br><span class="line">    <span class="keyword">return</span> x;<span class="comment">//返回x，int&amp; (&quot;function()&quot;) = x，因此函数甚至可以被赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    j = <span class="built_in">function</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, j);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">function</span>(i) = <span class="number">10</span>);<span class="comment">//函数也可以赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//但是返回值引用绝对不能返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n <span class="number">0</span>;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> n;<span class="comment">//错误返回，因为n被销毁了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ret = <span class="built_in">Count</span>();</span><br><span class="line">    cout &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用引用书写顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* a;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">&#125;SL;</span><br><span class="line"><span class="comment">//初始顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushInit</span><span class="params">(SL&amp; s, <span class="type">int</span> capacity = <span class="number">4</span>)</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">//尾插顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SLPushBack</span><span class="params">(SL&amp; S, <span class="type">int</span> x)</span></span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="comment">//修改顺序表</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">SLAt</span><span class="params">(SL&amp; s, <span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(pos &gt;= <span class="number">0</span> &amp;&amp; pos &lt;=s.size);</span><br><span class="line">    <span class="keyword">return</span> s.a[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SL sl;</span><br><span class="line">    <span class="built_in">SLPushInit</span>(sl);<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">1</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">2</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">3</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="built_in">SLPushBack</span>(sl, <span class="number">4</span>);<span class="comment">//尾插</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; sl.size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">SLAt</span>(sl, i) &lt;&lt; endl;<span class="comment">//输出顺序表的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">SLAt</span>(sl, <span class="number">0</span>)++;<span class="comment">//拿到s.a[pos]，对其进行++，这是只有C++才有的操作，C语言无法实现</span></span><br><span class="line">    <span class="built_in">SLAt</span>(sl, <span class="number">0</span>) = <span class="number">10</span>;<span class="comment">//拿到s.a[pos]，修改成10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-4-常引用"><a href="#6-2-4-常引用" class="headerlink" title="6.2.4.常引用"></a>6.2.4.常引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用类型的不匹配情况</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//int&amp; a1 = a;//错误引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; a1 = a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int&amp; b1 = 10;//错误引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b1 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="comment">//int&amp; c1 = c;//错误引用</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; c1 = c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用权限的变化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c = <span class="number">20</span>;<span class="comment">//c可读不可写</span></span><br><span class="line">    <span class="comment">//int&amp; d = c;//d把c权限放大了（可读可写），这是不被允许的</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; d = c;<span class="comment">//这是允许的，属于权限平移</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="number">30</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; f = e;<span class="comment">//但是权限缩小是被允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> g = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> h = g;<span class="comment">//这里产生一个临时变量，将存储数据提升后的g，再赋予（拷贝）h（这里g用显式强转也不行，无论是显式还是隐式，都不会改变g本身的类型）</span></span><br><span class="line">    <span class="comment">//double&amp; i = g;//这是不被允许的，因为这里产生一个临时变量，将存储数据提升后的g，而这个临时变量具有常属性，临时变量被h引用的话发生了权限放大</span></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; i = g;<span class="comment">//这是被允许的，只是发生了权限平移</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">double</span>&amp; j = <span class="number">3.14</span>;<span class="comment">//这个也是被允许的，因此拥有const修饰的引用允许引用常量。所以如果是在函数形参处使用引用时，如果不需要改变值，就要尽可能使用const修饰</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在C/C++中规定，类型转换（隐式和显式）过程会产生临时变量，如果我们使用const引用这个临时变量，则会让编译器延长这个临时变量的使用时间（生命周期）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：权限放大和缩小只适用在指针和引用上，普通变量之间的赋值是没有作权限要求的，因为这只是做一份临时拷贝。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_1</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_2</span><span class="params">(<span class="type">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function_3</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; n)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">function_1</span>(a);</span><br><span class="line">    <span class="built_in">function_1</span>(b);</span><br><span class="line">    <span class="built_in">function_1</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">function_2</span>(a);</span><br><span class="line">    <span class="comment">//function_2(b);//这是不被允许的</span></span><br><span class="line">    <span class="comment">//function_2(30);//这是不被允许的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">function_3</span>(a);</span><br><span class="line">    <span class="built_in">function_3</span>(b);</span><br><span class="line">    <span class="built_in">function_3</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; x = <span class="built_in">fun</span>();<span class="comment">//这里返回的a的拷贝，这个拷贝由一个临时变量维护，为了能被引用，被编译器延长了其生命周期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-引用和指针"><a href="#6-3-引用和指针" class="headerlink" title="6.3.引用和指针"></a>6.3.引用和指针</h2><p>指针更强大、更危险、更复杂&#x2F;引用局限一些、更安全、更简单。</p>
<table>
<thead>
<tr>
<th></th>
<th>引用</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td><strong>概念</strong></td>
<td>引用在概念上定义一个变量的别名</td>
<td>指针存储一个变量地址</td>
</tr>
<tr>
<td><strong>空间</strong></td>
<td>引用没有开空间</td>
<td>但是指针开了<code>4</code>个字节或是<code>8</code>个字节的空间（<code>32</code>位或者<code>64</code>位）</td>
</tr>
<tr>
<td><strong>初始</strong></td>
<td>引用在定义时必须初始化</td>
<td>指针被声明后可以不进行初始化</td>
</tr>
<tr>
<td><strong>赋值</strong></td>
<td>引用在初始化时引用一个实体后，就不能再引用其他实体</td>
<td>而指针可以在任何时候指向任何一个同类型实体</td>
</tr>
<tr>
<td><strong>置空</strong></td>
<td>没有<code>NULL</code>引用</td>
<td>但有<code>NULL</code>指针，但是<code>C++</code>改为<code>nullptr</code>指针</td>
</tr>
<tr>
<td><strong>大小</strong></td>
<td>在<code>sizeof</code>中含义不同，引用结果为引用类型的大小</td>
<td>但指针始终是地址空间所占字节个数(<code>32</code>位平台下占<code>4</code>个字节，<code>64</code>位平台下占<code>8</code>个字节）</td>
</tr>
<tr>
<td><strong>运算</strong></td>
<td>引用自加，即引用的实体增加<code>1</code>（加的是类型的<code>1</code>）</td>
<td>指针自加，即指针向后偏移一个类型的大小</td>
</tr>
<tr>
<td><strong>级别</strong></td>
<td>没有多级引用</td>
<td>但是有多级指针</td>
</tr>
<tr>
<td><strong>访问</strong></td>
<td>访问实体方式不同，引用编译器自己处理</td>
<td>指针需要显式解引用</td>
</tr>
<tr>
<td><strong>安全</strong></td>
<td>引用比指针使用起来相对更安全</td>
<td>使用不当时，严重时会使代码奔溃</td>
</tr>
</tbody></table>
<h1 id="7-内联函数"><a href="#7-内联函数" class="headerlink" title="7.内联函数"></a>7.内联函数</h1><h2 id="7-1-内联的概念"><a href="#7-1-内联的概念" class="headerlink" title="7.1.内联的概念"></a>7.1.内联的概念</h2><ol>
<li><p>内联关键字是<code>inline</code>，被其修饰的函数就叫内联函数</p>
</li>
<li><p>编译的时候，只要满足条件，<code>C++</code>编译器会在调用内联函数地方直接展开，没有函数调用建立栈帧的开销，内联函数能提升程序运行的效率，因此这是一种空间换时间的做法</p>
</li>
<li><p>内联关键字的使用很像宏的使用，可以说是宏的优化版本（但是宏：没有类型安全检查、容易出错、不易于调试）</p>
</li>
<li><p>内联可以嵌套内联函数使用</p>
</li>
<li><p>内联函数在<code>VS2022</code>的<code>debug</code>模式下默认是不展开的（<code>rlease</code>），这里打开反汇编就会发现依旧是调用函数，这是为了方便调试设计的，这是可以通过设置规避（“配置属性”-“<code>C/C++</code>”-“常规”-“调试信息格式”-“程序数据库(<code>/Zi</code>)”并且修改“配置属性”-“<code>C/C++</code>”-“优化”-“内联函数拓展”-“只使适用于 <code>__inline(/Obl)</code>”）来查看汇编代码（但是有的编译器不支持）。</p>
</li>
<li><p><code>inline</code>类似<code>C</code>语言里的寄存器变量关键字，只是向编译器发出一个请求，不同编译器关于<code>inline</code>的实现机制可能不一样，也就是说：内联申请不一定会成功！</p>
</li>
<li><p><code>inline</code>本质是一种空间换时间的做法。如果编译器将函数当成内联函数，在编译期间就会将函数体替换函数调用用，对应得优劣势有：<br> a.劣势，有可能使得目标文件变大<br> b.优势，少了调用开销，提高程序的运行效率</p>
</li>
<li><p>一般建议在以下情况来使用<code>inline</code>：将函数规模小、非递归、非频繁调用的函数采用<code>inline</code>修饰，否则编译器有可能会忽略<code>inline</code>的特性（这是因为，函数内部代码指令如果比较长，有可能会让编译的程序暴增，导致编译产生的程序变大。这些更多取决于编译器对<code>inline</code>的实现和理解）</p>
</li>
<li><p>另外被内联关键字修饰的函数，其声明和定义一般不建议分开写，分开有可能导致链接错误（尤其是不在一个翻译单元）。因此最好是把内联函数的声明和定义直接一起写到头文件里，不要去做分离（内联没有必要在符号表生成函数的地址，因此不会生成栈帧操作，链接的时候就会出现错误）！</p>
</li>
</ol>
<blockquote>
<p>补充：可以在同一个项目的不同源文件内定义函数名相同但实现不同的<code>inline</code>函数，因为<code>inline</code>函数会在调用的地方展开，所以符号表中不会有<code>inline</code>函数的符号名，不存在链接冲突这一说法。</p>
</blockquote>
<h2 id="7-2-内联的使用"><a href="#7-2-内联的使用" class="headerlink" title="7.2.内联的使用"></a>7.2.内联的使用</h2><h3 id="7-2-1-正确使用"><a href="#7-2-1-正确使用" class="headerlink" title="7.2.1.正确使用"></a>7.2.1.正确使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a = <span class="number">0</span>, <span class="type">int</span> b = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="comment">//被inline修饰的函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    c = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; c; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-不在同一个翻译单元"><a href="#7-2-2-不在同一个翻译单元" class="headerlink" title="7.2.2.不在同一个翻译单元"></a>7.2.2.不在同一个翻译单元</h3><p>下面看看一种错误的用法（）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.h内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//无法调用内联函数Add</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add_Inline</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; std::endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//对main.cpp来说定义和声明不在一个翻译单元里，无法链接（因为两个源文件属于不同的编译单元，它们会分别进行编译，而不会互相影响，最后链接的时候又不会有地址提供链接。）</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-3-共在同一个翻译单元"><a href="#7-2-3-共在同一个翻译单元" class="headerlink" title="7.2.3.共在同一个翻译单元"></a>7.2.3.共在同一个翻译单元</h3><p>再看看修改后的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.h内部</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_No_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inline.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Add_No_Inline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Add_Inline</span>(x, y);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp内部 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;inline.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//成功调用内联函数Add，对inline.cpp来说定义和声明在一个翻译单元里，</span></span><br><span class="line">    <span class="comment">//内联函数是在一个翻译单元内被展开并且在内部被使用的，所以可以使用 </span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">Add_No_Inline</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4-内联和宏量"><a href="#7-4-内联和宏量" class="headerlink" title="7.4.内联和宏量"></a>7.4.内联和宏量</h2><table>
<thead>
<tr>
<th>宏的优点</th>
<th>宏的缺点</th>
</tr>
</thead>
<tbody><tr>
<td>提高代码的复用性（让你的代码能适应更多种的情况，完成更多种情况的任务，这就是代码的复用性）代码的可维护性变强，修改某些常量值快捷方便</td>
<td>不方便调试带有宏的代码（因为预编译阶段进行了替换，而调试是在编译后的）</td>
</tr>
<tr>
<td>宏函数能提高效率，减少栈帧的建立</td>
<td>导致代码的可读性差、有一点的复杂性，容易误用</td>
</tr>
<tr>
<td></td>
<td>没有类型安全的检查（替换机制），易出现类型错误</td>
</tr>
</tbody></table>
<p>宏的代替方案有如下两点：</p>
<ol>
<li><p>常量定义可以使用<code>C++</code>的<code>const</code>、<code>enum</code>代替宏常量</p>
</li>
<li><p>短小函数定义可以使用<code>C++</code>的内联关键字<code>inline</code>代替宏函数</p>
</li>
</ol>
<h2 id="7-6-内联的约定"><a href="#7-6-内联的约定" class="headerlink" title="7.6.内联的约定"></a>7.6.内联的约定</h2><p>在现代<code>C++</code>中，基本建议尽量使用<code>const</code>、<code>enum</code>、<code>inline</code>，而不使用宏。</p>
<blockquote>
<p>补充：</p>
<ol>
<li><p><code>const</code>定义的常量只有一次拷贝（就是只有一个值）</p>
</li>
<li><p>而<code>define</code>定义的变量在内存中并没有拷贝，因为所有的预处理指令都在预处理时进行了替换</p>
</li>
</ol>
</blockquote>
<h1 id="8-typedef和auto"><a href="#8-typedef和auto" class="headerlink" title="8.typedef和auto"></a>8.typedef和auto</h1><h2 id="8-1-typedef关键字"><a href="#8-1-typedef关键字" class="headerlink" title="8.1.typedef关键字"></a>8.1.typedef关键字</h2><p>随着一个工程的扩大，程序中用到的类型也越来越复杂，经常体现在：</p>
<ol>
<li><p>类型难以拼写，容易拼错</p>
</li>
<li><p>含义不明确，导致用错</p>
</li>
</ol>
<p>在编程时，常常需要把表达式的值赋值给变量，这就要求在声明变量的时候就要清楚知道表达式的类型。要做到这点并非那么容易，而<code>typedef</code>也还不够智能，而且因此<code>C++11</code>给<code>auto</code>一个新的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*没有使用tepedef重命名*/</span></span><br><span class="line"><span class="comment">//这段代码现在看不懂没关系，您只需要知道类型的名字确实很长就对了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;std::string, std::string&gt;m&#123; &#123; <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;苹果&quot;</span> &#125;, &#123; <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;橙子&quot;</span> &#125;, &#123;<span class="string">&quot;pear&quot;</span>, <span class="string">&quot;梨&quot;</span>&#125; &#125;;</span><br><span class="line">    std::map&lt;std::string, std::string&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//其中std::map&lt;std::string,std::string&gt;::iterator是一个类型，但是类型的名字太长了，容易写错，可以尝试使用typedef给这个类型取个别名</span></span><br><span class="line">    <span class="keyword">while</span> (it != m.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//....    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-2-auto关键字"><a href="#8-2-auto关键字" class="headerlink" title="8.2.auto关键字"></a>8.2.auto关键字</h2><ol>
<li><p>在<code>C++11</code>的标准中，<code>auto</code>不再是存储类型说明符，而是一个新的类型指示符，来指示编译器</p>
</li>
<li><p><code>auto</code>声明的变量必须由编译器在编译时期推导而得 </p>
</li>
<li><p>使用<code>auto</code>定义变量时必须对其进行初始化，在编译阶段编译器会根据初始化表达式来推导<code>auto</code>的实际类型。因此<code>auto</code>并非是一种“类型”的声明，而是一个类型声明时的“占位符”，编译器在编译期会将auto替换为变量实际的类型。</p>
</li>
</ol>
<p>如果结合指针和引用来使用（这实际上也是指针和引用的区别之一）：</p>
<ol>
<li><p>结合指针的话，<code>auto</code>和<code>auto*</code>是没有区别的</p>
</li>
<li><p>结合引用的话，<code>auto</code>和<code>auto&amp;</code>是有区别的，必须要加<code>&amp;</code></p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//一个变量</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.结合指针</span></span><br><span class="line">    <span class="keyword">auto</span> a = &amp;x;</span><br><span class="line">    <span class="keyword">auto</span>* b = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.结合引用</span></span><br><span class="line">    <span class="keyword">auto</span> c = x;</span><br><span class="line">    <span class="keyword">auto</span>&amp; d = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试类型和输出，typeid可以打印类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(c).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(d).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.修改变量</span></span><br><span class="line">    *a = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    *b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; x&lt;&lt; endl;</span><br><span class="line">    c = <span class="number">30</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    d = <span class="number">40</span>;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在同一行使用<code>auto</code>来声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型定义其他变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//正确使用  </span></span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//错误使用 </span></span><br><span class="line">    <span class="comment">//auto c = 3, d = 4.0;//该行代码会编译失败，因为c和d的初始化表达式类型不同    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>auto</code>不能推导的场景有：</p>
<ol>
<li><p><code>auto</code>不能作为函数的形参，因为函数编译是要建立栈帧的，这个时候都不知道形参的大小，怎么知道从哪里开始创建栈帧呢？ </p>
</li>
<li><p><code>auto</code>不能用来声明数组</p>
</li>
</ol>
<p>另外，为了避免和<code>C++98</code>的<code>auto</code>发生混淆，<code>C++11</code>只保留了<code>auto</code>作为类型指示符的用法。</p>
<p><code>auto</code>的最大的优势其实在于<code>C++11</code>提供的新式<code>for</code>循环以及<code>lambda</code>表达式，<code>lambda</code>表达式我们先不提，但是下面我们来了解一下范围<code>for</code>。</p>
<h1 id="9-基于范围的for循环"><a href="#9-基于范围的for循环" class="headerlink" title="9.基于范围的for循环"></a>9.基于范围的for循环</h1><p>这不是<code>C++</code>的首创，而是借鉴其他语言引入进来的。</p>
<h2 id="9-1-范围for的使用"><a href="#9-1-范围for的使用" class="headerlink" title="9.1.范围for的使用"></a>9.1.范围for的使用</h2><ol>
<li>在<code>C++</code>98之前，遍历一个数组可以按照以下的方式使用</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使用C++98遍历方式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        array[i] *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>* p = array; p &lt; array + <span class="built_in">sizeof</span>(array)/ <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); ++p)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>C++11</code>中可以使用基于范围的<code>for</code>循环。<code>for</code>后面的括号由冒号<code>:</code>分为两部分，第一部分是范围内用于迭代的变量，第二部分表示被迭代的范围</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使用C++11遍历方式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : array)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : array)</span><br><span class="line">        cout &lt;&lt; e &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-2-范围for的条件"><a href="#9-2-范围for的条件" class="headerlink" title="9.2.范围for的条件"></a>9.2.范围for的条件</h2><p>由于<code>C++</code>不支持直接传数组（这样消耗大，浪费）所以在函数传数组的时候必须提供<code>begin</code>和<code>end</code>方法，<code>begin</code>和<code>end</code>就是<code>for</code>循环迭代的范围（有关<code>begin</code>和<code>end</code>的具体使用后面在使用<code>string</code>类再说）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">int</span> arr[])</span><span class="comment">//这个函数是不正确的，因为arr不是数组名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : arr)<span class="comment">//无法使用范围for</span></span><br><span class="line">        cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-指针空值nullptr"><a href="#10-指针空值nullptr" class="headerlink" title="10.指针空值nullptr"></a>10.指针空值nullptr</h1><h2 id="10-1-NULL的概念"><a href="#10-1-NULL的概念" class="headerlink" title="10.1.NULL的概念"></a>10.1.NULL的概念</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NULL实际是一个宏，在传统的C头文件(stddef.h)中，可以看到如下代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL 0<span class="comment">//在C++语言中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULL ((void *)0)<span class="comment">//在C语言中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">//在C++98中，字面量0既可以是一个整型数字，也可以是无类型的指针(void*)常量，但是编译器默认情况下将其看作整型常量，如果这么使用NULL时，就会具有一定的麻烦，这是C++设计的一个失误，都是C++不敢去掉这个定义，为了保证兼容性就新定义了nullptr。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f(int)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>*)</span><span class="comment">//函数重载</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;f(int*)&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">NULL</span>);<span class="comment">//误用第一个函数，因为处理NULL的时候，NULL是被定义为0的</span></span><br><span class="line">    <span class="built_in">f</span>((<span class="type">int</span>*)<span class="literal">NULL</span>);<span class="comment">//需要使用强制类型转换才可以使用第二个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2-nullptr的概念"><a href="#10-2-nullptr的概念" class="headerlink" title="10.2.nullptr的概念"></a>10.2.nullptr的概念</h2><ol>
<li><p>而在使用<code>nullptr</code>表示指针空值时，不需要包含头文件，因为<code>nullptr</code>是<code>C++11</code>作为新关键字引入的6</p>
</li>
<li><p>在<code>C++11</code>中，<code>sizeof(nullptr)</code>与<code>sizeof((void*)0)</code>所占的字节数相同</p>
</li>
<li><p>为了提高代码的健壮性，在后续表示指针空值时建议最好使用<code>nullptr</code></p>
</li>
</ol>
<h1 id="11-decltype"><a href="#11-decltype" class="headerlink" title="11.decltype"></a>11.decltype</h1><p><code>decltype</code> 可以根据表达式的类型来创建变量，某些时候可以使用 <code>auto</code> 替代，但有些情况不可以。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">2.3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//decltype 可以根据表达式的类型来创建变量</span></span><br><span class="line">    <span class="keyword">decltype</span>(x * y) ret;<span class="comment">//ret的类型变成了 double</span></span><br><span class="line">    <span class="keyword">decltype</span>(&amp;x) p;<span class="comment">//p的类型变成了 const int*</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(ret).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(p).<span class="built_in">name</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/01/1-C-%E5%AF%BC%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="limou3434">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2023/12/01/1-C-%E5%AF%BC%E8%AE%BA/" itemprop="url">1.C++导论</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2023-12-01T18:06:08+08:00">
                2023-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-何为C"><a href="#1-何为C" class="headerlink" title="1.何为C++"></a>1.何为C++</h1><p><code>C</code>语言是关于结构化和模块化的语言，比较适合处理较小规模的程序。而对于复杂的问题，规模较大的程序，需要高度的抽象和建模时，<code>C</code>语言则变得很不适用且麻烦。</p>
<p>在20世纪80年代，计算机界提出了<code>OOP</code>思想（面向对象思想）支持面向对象的程序设计语言（例如<code>C++</code>、<code>Java</code>等）应运而生。</p>
<p><code>1982</code>年，<code>Bjarne Stroustrup</code>博士在<code>C</code>语言的基础上引入并扩充了面向对象的概念，发明了一种新的程序语言。为了表达该语言与<code>C</code>语言的渊源关系，命名为<code>C++</code>。</p>
<p>因此<code>C++</code>是基于<code>C</code>语言而产生的，它既可以进行<code>C</code>语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行面向对象的程序设计，并且还支持泛型编程，并且增加了许多有用的库（<code>C++</code>是<code>C</code>的超集，包含C的内容，兼容C的运行）。</p>
<blockquote>
<p>补充：有关<code>Bjarne Stroustrup</code>，您可以去他的<a target="_blank" rel="noopener" href="https://www.stroustrup.com/">Bjarne Stroustrup的个人博客</a>那里逛一下。</p>
</blockquote>
<p>学习<code>C++</code>语言，最直接的好处是：可以明白<code>C</code>语言设计不合理的地方，明白面向对象编程是怎么一回事，交织<code>C</code>和<code>C++</code>可以窥探对现代编程语言的变化。</p>
<h1 id="2-C-发展简史"><a href="#2-C-发展简史" class="headerlink" title="2.C++发展简史"></a>2.C++发展简史</h1><ol>
<li><p><code>C with classes</code>：<code>1979</code>年贝尔实验室<code>Bjarne Stroustrup</code>等人试图分析<code>unix</code>内核的时候，将内核模块化，于是在<code>C</code>语言的基础上进行扩展，增加了类的机制，完成了一个可以运行的预处理程序，称之为<code>C with classes</code>（具备功能：类及派生类、公有和私有成员、类的构造和析构、友元、内联函数、赋值运算符、重载等）。</p>
</li>
<li><p><code>C++1.0</code>：添加虚函数概念、函数和运算符重载、引用、常量等。</p>
</li>
<li><p><code>C++2.0</code>：新增保护成员、多重继承、对象的初始化、抽象类、静态成员、const成员函数等。</p>
</li>
<li><p><code>C++3.0</code>：引入模板、解决多重继承产生的二义性问题、解决相应构造和析构的处理。</p>
</li>
<li><p><code>C++98</code>：<code>C++</code>标准的第一个版本，绝大多数编译器都支持，得到了国际标准化组织（<code>ISO</code>）和美国标准化协会认可，以模板方式重写<code>C++标准库</code>，引入了<code>STL</code>（标准模板库）</p>
</li>
<li><p><code>C++03</code>：<code>C++</code>标准第二个版本，语言特性无大改变，主要：修订错误、减少多异性</p>
</li>
<li><p><code>C++05</code>：<code>C++</code>标准委员会发布了一份计数报告（<code>Technical Report</code>，<code>TR1</code>），正式更名<code>C++0x</code>，即：计划在本世纪第一个<code>10</code>年的某个时间发布。</p>
</li>
<li><p><code>C++11</code>：增加了许多特性，使得<code>C++</code>更像一种新语言，比如：正则表达式、基于范围<code>for</code>循环、<code>auto</code>关键字、新容器、列表初始化、标准线程库等。</p>
</li>
<li><p><code>C++14</code>：对<code>C++11</code>的扩展，主要是修复<code>C++11</code>中漏洞以及改进，比如：泛型的<code>lambda</code>表达式，<code>auto</code>的返回值类型推导，二进制字面常量等。</p>
</li>
<li><p><code>C++17</code>：在<code>C++11</code>上做了一些小幅改进，增加了<code>19</code>个新特性，比如：<code>static_assert()</code>的文本信息可选，<code>Fold</code>表达式用于可变的模板，<code>if</code>和<code>switch</code>语句中的初始化器等。</p>
</li>
<li><p><code>C++20</code>：自<code>C++11</code>以来最大的发行版，引入了许多新的特性，比如：模块（<code>Modules</code>）、协程（<code>Coroutines</code>）、范围（<code>Ranges</code>）、概念（<code>Constraints</code>）等重大特性，还有对已有特性的更新：比如<code>Lambda</code>支持模板、范围<code>for</code>支持初始化等。</p>
</li>
</ol>
<h1 id="3-C-常见邻域"><a href="#3-C-常见邻域" class="headerlink" title="3.C++常见邻域"></a>3.C++常见邻域</h1><ol>
<li><p>操作系统或者大型系统软件开发（JVM、Office）</p>
</li>
<li><p>服务器端开发</p>
</li>
<li><p>游戏开发（虚幻4）</p>
</li>
<li><p>嵌入式和物联网（扫地机器人）</p>
</li>
<li><p>数字图像处理（<code>Photoshop</code>）</p>
</li>
<li><p>人工智能（深度学习算法）</p>
</li>
<li><p>分布式应用</p>
</li>
</ol>
<h1 id="4-C-阅读书籍"><a href="#4-C-阅读书籍" class="headerlink" title="4.C++阅读书籍"></a>4.C++阅读书籍</h1><h1 id="5-C-学习层次"><a href="#5-C-学习层次" class="headerlink" title="5.C++学习层次"></a>5.C++学习层次</h1><p>以下引用自<code>2010</code>年<code>8</code>月号《程序员》刊登的拙文《<code>C++</code>强大背后》最后一段</p>
<ol>
<li><p>第一个层次：</p>
<p> C++基础</p>
</li>
<li><p>第二个层次：正确高效的使用C++：</p>
<p> 开始自修，阅读过《<code>(More)Effective C++</code>》、《<code>(More)Exceptional C++</code>》、《<code>Effective STL</code>》及《<code>C++</code>编程规范》等，踏入专业<code>C++</code>开发之路;</p>
</li>
<li><p>第三个层次，深入解读C++：</p>
<p> 关于全局问题可读《深入探索C++对象模型》、《<code>Imperfect C++</code>》、《<code>C++</code>沉思录》、《<code>STL</code>源码剖析》，要挑战智商，可看关于模版及模版元编程的书籍如《<code>C++ Templates</code>》、《<code>C++</code>设计新思维》、《<code>C++</code>模版元编程》</p>
</li>
<li><p>第四个层次，研究C++：</p>
<p> 阅读《<code>C++</code>语言的设计和演化》、《编程的本质》（含<code>STL</code>设计背后的数学根基）、<code>C++</code>标准文件《<code>ISO/IEC 14882:2003</code>》、<code>C++</code>标准委员会的提案书和报告书、关于<code>C++</code>的学术文献。<code>C++</code>只是软件开发的一环而已，单凭语言并不能应付业务和工程上的问题。不要强求几年内“彻底学会<code>C++</code>的知识”，到达第二层左右便从工作实战中汲取经验，有兴趣才慢慢继续学习更高层次的知识。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%20%7C%7C%20archive">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">limou</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
